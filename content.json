{"pages":[],"posts":[{"title":"About Dynamic-Point Segment Tree","text":"自己瞎取的名字，就是动态开点线段树。大概思想当空间不够用的时候，随时可以删点和新建点，比较灵活。下面是几个例子，有的是值域线段树，有的是普通坐标的线段树。 P1908 逆序对 本来是树状数组水题，现在变成了奇怪的动态开点值域线段树模板题。其实不用值域线段树也可以。普通线段树就要离散化然后按照单调递增的顺序加 value，再 query。多麻烦啊，所以一个值域线段树解决问题。 因为最大值 MAX 为 $10^9$，所以 inf 设为 $10^9$。因为每一次查询的是当前点往右的点数，所以要特判 l&gt;r 的情况。因为 inf=1e9，所以查询 1e9+1 就会炸掉，所以要特判。其实把 inf 变成 1e9+10 不是一样的吗 那么代码如下。 因为线段树平均链深度为 $\\log$ 级别。所以开 $N \\log N$ 大小的线段树。动态开点线段树的优势在这道题还真没体现出来（ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N = 1e7 + 10;const int inf = 1e9 + 10;int n, cnt, root, tree[N];int a[N], ls[N], rs[N];void read(int &amp;ret) { ret = 0; char ch = getchar(); while (!isdigit(ch)) ch = getchar(); while (isdigit(ch)) { ret = (ret&lt;&lt;1) + (ret&lt;&lt;3) + (ch^48); ch = getchar(); } return ;}void upd(int &amp;rt, int l, int r, int val, int f) { if (!rt) rt = ++cnt; if (l==r) { tree[rt] += f; return ; } int mid = (l+r) &gt;&gt; 1; if (val&lt;=mid) upd(ls[rt], l, mid, val, f); else upd(rs[rt], mid+1, r, val, f); tree[rt] = tree[ls[rt]] + tree[rs[rt]]; return ;}int query(int rt, int l, int r, int L, int R) { if (!rt) return 0; if (L&lt;=l &amp;&amp; r&lt;=R) return tree[rt]; int mid = (l+r) &gt;&gt; 1, ans = 0; if (L&lt;=mid) ans += query(ls[rt], l, mid, L, R); if (R&gt;mid) ans += query(rs[rt], mid+1, r, L, R); return ans;}int main() { read(n); ll ans = 0; for (int i=1; i&lt;=n; ++i) { int x; read(x); ans += (ll)query(root, 1, inf, x+1, inf); upd(root, 1, inf, x, 1); } printf(&quot;%lld\\n&quot;, ans); return 0;} 跑了 4s 多，还不如写普通线段树（bu P3313 旅行 虽然是个紫题，但是是个水紫。 首先问题可以简化成树上染色问题，四个 option 变成下面这样。 某个节点被重新染色 节点权值被修改 求路径上某种颜色权值和 求路径上某种颜色最大权值 那么考虑对于每一个颜色开一棵动态开点线段树。然后直接树链剖分乱搞。（轻重链剖分）对于 option 3 和 4 随便乱搞都可以过。 但是对于 option 1，可以转化为在树中删点，再丢到另一棵树里。option 2 直接修改当前权值即可。 所以想到 pushup 操作。可以将节点的 MAX 和 SUM 直接变成 0。接着删点（就这么做！）跑路。然后在另一棵树里面新建节点，只需要丢进去即可。然后修改颜色（即要修改节点所属树根）。或者是修改当前的权值。注意要 remove 和 update 之后做。 然后就没了。 似乎并不毒瘤？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include &lt;bits/stdc++.h&gt;using namespace std;void read(int &amp;ret) { ret = 0; char ch = getchar(); while (!isdigit(ch)) ch = getchar(); while (isdigit(ch)) { ret = (ret&lt;&lt;1) + (ret&lt;&lt;3) + (ch^48); ch = getchar(); } return ;}const int MAXN = 1e5 + 10;const int MAX_SIZE = 2e7;int n, Q, cnt, tot/*build-cnt*/, idx;int w[MAXN], c[MAXN], wl[MAXN], wc[MAXN];int dep[MAXN], siz[MAXN], fa[MAXN], son[MAXN];int tp[MAXN], root[MAXN], id[MAXN];char opt[3]; int head[MAXN&lt;&lt;1];struct Edge { int to, nxt; } e[MAXN&lt;&lt;1];void addEdge(int u, int v) { e[++cnt].to = v; e[cnt].nxt = head[u]; head[u] = cnt; return ;}void dfs1(int cur, int f) { fa[cur] = f, siz[cur] = 1; dep[cur] = dep[f] + 1; int heavyson = -1; for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (to == f) continue; dfs1(to, cur), siz[cur] += siz[to]; if (siz[to] &gt; heavyson) heavyson = siz[to], son[cur] = to; } return ;}void dfs2(int cur, int Tp) { tp[cur] = Tp, id[cur] = ++idx; if (!son[cur]) return ; dfs2(son[cur], Tp); for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (to==fa[cur] || to==son[cur]) continue; dfs2(to, to); } return ;}struct seg { int ls, rs, Max, val; } tree[MAX_SIZE];void pushup(int rt) { tree[rt].val = tree[tree[rt].ls].val + tree[tree[rt].rs].val; tree[rt].Max = max(tree[tree[rt].ls].Max, tree[tree[rt].rs].Max); return ;}void upd(int &amp;rt, int l, int r, int pos, int W) { if (!rt) rt = ++tot; if (l==r) { tree[rt].val = tree[rt].Max = W; return ; } int mid = (l+r) &gt;&gt; 1; if (pos&lt;=mid) upd(tree[rt].ls, l, mid, pos, W); else upd(tree[rt].rs, mid+1, r, pos, W); pushup(rt); return ;}void remv(int rt, int l, int r, int pos) { if (l==r) { tree[rt].val = tree[rt].Max = 0; return ; } int mid = (l+r) &gt;&gt; 1; if (pos&lt;=mid) remv(tree[rt].ls, l, mid, pos); else remv(tree[rt].rs, mid+1, r, pos); pushup(rt); return ;}int querys(int rt, int l, int r, int L, int R) { if (L&lt;=l &amp;&amp; r&lt;=R) return tree[rt].val; int mid = (l+r) &gt;&gt; 1, ans = 0; if (L&lt;=mid) ans += querys(tree[rt].ls, l, mid, L, R); if (R&gt;mid) ans += querys(tree[rt].rs, mid+1, r, L, R); return ans;}int querym(int rt, int l, int r, int L, int R) { if (L&lt;=l &amp;&amp; r&lt;=R) return tree[rt].Max; int mid = (l+r) &gt;&gt; 1, ans = 0; if (L&lt;=mid) ans = max(ans, querym(tree[rt].ls, l, mid, L, R)); if (R&gt;mid) ans = max(ans, querym(tree[rt].rs, mid+1, r, L, R)); return ans;}int qus(int l, int r, int rel) { int ans = 0; while (tp[l] ^ tp[r]) { if (dep[tp[l]] &lt; dep[tp[r]]) swap(l, r); ans += querys(root[rel], 1, n, id[tp[l]], id[l]); l = fa[tp[l]]; } if (dep[l] &gt; dep[r]) swap(l, r); ans += querys(root[rel], 1, n, id[l], id[r]); return ans;}int qum(int l, int r, int rel) { int ans = 0; while (tp[l] ^ tp[r]) { if (dep[tp[l]] &lt; dep[tp[r]]) swap(l, r); ans = max(ans, querym(root[rel], 1, n, id[tp[l]], id[l])); l = fa[tp[l]]; } if (dep[l] &gt; dep[r]) swap(l, r); ans = max(ans, querym(root[rel], 1, n, id[l], id[r])); return ans;}int main() { read(n), read(Q); for (int i=1; i&lt;=n; ++i) read(w[i]), read(c[i]); for (int i=1; i&lt;n; ++i) { int u, v; read(u), read(v); addEdge(u, v); addEdge(v, u); } dfs1(1, 1), dfs2(1, 1); for (int i=1; i&lt;=n; ++i) upd(root[c[i]], 1, n, id[i], w[i]); while (Q--) { cin &gt;&gt; opt+1; int u, v; read(u), read(v); if (opt[2] == 'C') { remv(root[c[u]], 1, n, id[u]); upd(root[v], 1, n, id[u], w[u]); c[u] = v; } else if (opt[2] == 'W') { remv(root[c[u]], 1, n, id[u]); upd(root[c[u]], 1, n, id[u], v); w[u] = v; } else if (opt[2] == 'S') printf(&quot;%d\\n&quot;, qus(u, v, c[u])); else if (opt[2] == 'M') printf(&quot;%d\\n&quot;, qum(u, v, c[u])); } return 0;}","link":"/2021/08/04/About-Dynamic-Point-Segment-Tree/"},{"title":"CF961G Solution","text":"CF961G Partitions 这题好神啊 … 我发现我一直 WA5 的原因是开始统计和的时候没有取模（然后就想着写篇题解记录一下 … 首先题目不是要求一个和吗。 那么通过人类智慧发现很显然所有数出现的次数都是一样的。也就是说最后的和式必然是 $…\\times \\sum\\limits_{i=1}^nw_i$ 这样的形式。 那么不妨将前面的系数设为 $p$。 我们对于这个问题其实可以用 DP 的思想来解决。我们对于求整个柿子的系数，直接考虑枚举子集大小。然后就可以发现我们当前选了 $i$ 个，然后算出自己集合的方案和别的集合的方案即可。最后相乘累加就是答案，其中运用的是第二类斯特林数的思想。 第二类斯特林数就解决的是这样一类问题： $n$ 个物品放入 $m$ 个不同集合中，求集合非空的总方案数。 想要研究的同学可以自行研究，这里不再赘述。 所以就可以得到系数 $p$ 变成了下面的柿子。 $$p=\\sum\\limits_{i=1}^ni\\binom{n-1}{i-1}S_2(n-i,k-1)$$$$=\\sum\\limits_{i=1}^ni\\binom{n-1}{i-1}\\dfrac{1}{(k-1)!}\\sum\\limits_{j=0}^{k-1}(-1)^j\\binom{k-1}{j}(k-j-1)^{n-i}$$$$=\\sum\\limits_{i=1}^ni\\binom{n-1}{i-1}\\dfrac{1}{(k-1)!}\\sum\\limits_{j=0}^{k-1}(-1)^j\\dfrac{(k-1)!}{j!\\times(k-j-1)!}(k-j-1)^{n-i}$$$$=\\sum\\limits_{i=1}^ni\\binom{n-1}{i-1}\\sum\\limits_{j=0}^{k-1}\\dfrac{(-1)^j(k-j-1)^{n-i}}{j!\\times(k-j-1)!}$$$$=\\sum\\limits_{j=0}^{k-1}\\dfrac{(-1)^j}{j!\\times(k-j-1)!}\\sum\\limits_{i=1}^ni\\binom{n-1}{i-1}(k-j-1)^{n-i}$$ 注意上面将 $j$ 的和式提前了，这显然是正确的。因为分母相同相加分母不变，然后 $-1$ 的系数显然只和 $j$ 有关。但是分子剩下的部分 $(k-j-1)^{n-i}$ 显然和 $i$ 和 $j$ 都有关。所以为了方便后面的推导，这里直接将 $j$ 提前作为后面那一堆和的系数。这里说的 方便推导 其实也没有什么非常清晰的界定，只是这部分可以简单解决。当然不排除有暴力老哥直接卷的情况。（其实我也不知道可不可以卷，因为我没学多项式（（ 所以看到一大堆阶乘，在保证答案正确性的情况下，直接从一大堆柿子里面拎出来是必要的。 然后后面那个 $(k-j-1)$ 看起来特别丑，弄成 $s$。 $$\\sum\\limits_{i=1}^ni\\binom{n-1}{i-1}s^{n-i}$$$$=\\sum\\limits_{i=1}^ni\\times s^{n-i}\\dfrac{(n-1)!}{(i-1)! \\times (n-i)!}$$ 为了约分上面的组合数拆开了。 然后有一个 trick，看到分母有一个 $i-1$，看到前面的系数 $i$，所以把那个 $i$ 给拆掉，拆成 $i=i-1+1$。 所以有 $$=\\sum\\limits_{i=1}^ns^{n-i}\\times(i-1+1)\\dfrac{(n-1)!}{(i-1)! \\times (n-i)!}$$$$=\\sum\\limits_{i=1}^ns^{n-i}[(i-1)\\times \\dfrac{(n-1)!}{(i-1)! \\times (n-i)!}+\\dfrac{(n-1)!}{(i-1)! \\times (n-i)!}]$$$$=\\sum\\limits_{i=1}^ns^{n-i}(i-1)\\dfrac{(n-1)!}{(i-1)! \\times (n-i)!}+\\sum\\limits_{i=1}^ns^{n-i}\\dfrac{(n-1)!}{(i-1)! \\times (n-i)!}$$ 然后约掉共同的 $i-1$。 $$=\\sum\\limits_{i=1}^ns^{n-i}\\dfrac{(n-1)!}{(i-2)! \\times (n-i)!}+\\sum\\limits_{i=1}^n\\dfrac{(n-1)!}{(i-1)! \\times (n-i)!}$$ 再重新写成方便的组合数形式。 $$=\\sum\\limits_{i=1}^ns^{n-i}\\binom{n-1}{i-2}+\\sum_{i=1}^ns^{n-i}\\binom{n-1}{i-1}$$ 由于这个上下不统一所以把 $(n-1)$ 提出来。 $$=(n-1)\\sum\\limits_{i=1}^ns^{n-i}\\binom{n-2}{i-2}+\\sum\\limits_{i=1}^ns^{n-i}\\binom{n-1}{i-1}$$ 然后发现这个玩意儿好像很不好算，所以变成下面这样，因为 $\\binom{n}{m}=\\binom{n}{n-m}$。 $$=(n-1)\\sum\\limits_{i=1}^ns^{n-i}\\binom{n-2}{n-i}+\\sum\\limits_{i=1}^ns^{n-i}\\binom{n-1}{n-i}$$ 然后根据那个什么柿子的展开，就是杨辉三角的系数，观察到 $n-i$ 的共同部分可以运用上这个公式，可以发现这个可以直接把组合数拆开变成幂。 实际上那个 $\\sum\\limits_{i=1}^n$ 有一些项应该是不能算的，因为组合数其实等于 $0$。所以根据 $(a+b)^n$ 的系数其实就是组合数，可以直接代进去。 即 $(a+b)^n=\\sum\\limits_{i=0}^n\\binom{n}{i}a^{n-i}b^i$。 应该长成这样吧，不太确定有没有问题。 所以又可以化简成下面那样。 $$=(n-1)(s+1)^{n-2}+(s+1)^{n-1}$$$$=(s+1)^{n-2}(s+1+n-1)$$$$=(s+1)^{n-2}(s+n)$$ 然后就可以代回去了。 $$p=\\sum\\limits_{j=0}^{k-1}\\dfrac{(-1)^j}{j!\\times(k-j-1)!}[(n-1)(k-j)^{n-2}+(k-j)^{n-1}]$$$$=\\sum\\limits_{j=0}^{k-1}\\dfrac{(-1)^j}{j!\\times(k-j-1)!}(k-j)^{n-2}(n+k-j-1)$$ 所以就可以得出代码了。我的时间复杂度比较劣，代码还是参考别人的吧。 时间复杂度 $\\Theta(k \\log \\text{Mod})$。 不要问我为什么后面是 $\\text{Mod}$ 而不是 $n$（问就是逆元没有线性求，直接 qpow(x,mod-2)（（（ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 2e5 + 10;const int MOD = 1e9 + 7;int n, k, cnt, sum, a, jc[N];void init() { jc[0] = jc[1] = 1ll; for (int i=2; i&lt;=k; ++i) jc[i] = jc[i-1] * i % MOD; // 预处理阶乘 return ;}int qpow(int bas, int pw) { int mult = 1ll; while (pw) { if (pw &amp; 1ll) mult = mult * bas % MOD; bas = bas * bas % MOD; pw /= 2; // 貌似是个 UB，不能写 &gt;&gt;=1ll } return mult;}int inv(int x) { return qpow(x, MOD-2); }signed main() {// freopen(&quot;sum.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;sum.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%lld%lld&quot;, &amp;n, &amp;k); init(); for (int i=1; i&lt;=n; ++i) scanf(&quot;%lld&quot;, &amp;a), cnt = (cnt + a) % MOD; int Sum = 0; for (int i=0; i&lt;k; ++i) { int cur = inv(jc[i]); cur = cur * inv(jc[k-i-1]) % MOD; int f = i&amp;1? -1 : 1; cur = f * cur % MOD, cur = (cur % MOD + MOD) % MOD; cur = cur * qpow(k-i, n-2) % MOD; cur = cur * (n+k-i-1) % MOD; Sum = (Sum + cur) % MOD; // 对于分母求逆元再乘分子，基本操作 } cout &lt;&lt; Sum * cnt % MOD &lt;&lt; endl; return 0;}","link":"/2021/08/04/CF961G-Solution/"},{"title":"Interesting Faults","text":"27f4d61e79f0c9d33d7e8e5b0fa1d1b1af4ed74958cdeecf5e608d4f67d0d6eeb9b952074f07a9bffeac8ec075695456a75760abbcfdb25c0f5c6ac452b63c76e9892bbba6052dd73061ee52a97254b3125af8c8fb03d331d366220ee2f01af9d346ebf819c6541d09bf93c4ea3f56ccba9ed1561bca8692fbe251883d424c995f4ae27f5243eaca9835e405546d078fbaf040786eec156a66d3d6b4a0fa7a4a16ddaf5cb4b80b63f4ca9a3a5724c814fc9211997ded0a963b948f39c29ecfcb8db28c598856e6fd26604278332ecc5af14fbc89571a195fa935cfda2a7bd31cc3eae74773a77f56996a66e1ae74f801f3a4c72e1821ef2664227011abd036063fc665b5e93d2867e4b1410c4805b7dc9169c97d8005c367cda440596d38d5b7bdd822e4a1748a9e73d4ba9352db18bd5ae6545574a9c420db40f4d41782e39b716cb19e06c0bfc6eb4d9059c1a02a37ba1f7507dd5f770d0f1e1ed158a1d86752e84a9094ac8b79e1007f857b3581a467c822fa5f80fb624584d55629a7281c7d5769e591df6b3554e6447eb82dfc8023c9eef646b070cd3d307850477e3cf42a7e641c9a64b150b5fa5d7d4d0f645ea0304d859c4b83a26f02434228f1072e630454a4a6f8718294194341a1c506d8cfc1bb0b60ca27033b2e3569bdfa5a435d8aff9a49b314fe4a32dcd4f70579a86c9ae792ac1a1649f3964893e4374e5ddc37b3a76b674afad4e93226506159ce83422f269f747a18651ef883a17c4a6524819c3187fc7242c6454ab72da3b039795f3f4ff54880c651a0eca0f23659f535369845dc7a246bace26296e35e670a12d1b9f00ba054c96e62b4b43d05e69d43a70c6de5689d429c5a7eb739bc62b6c7eb9ca04381de168db1d6c7f00589403e3802a8eb6aa267f94beb6036d0decd32f0b7fb263c14a62daad5f32554f6ff1fc1400d21bb77fe2905d92e763b35971409986904c59dad01e21d3f3a2746c4f5f9dae24b81498c2e27066d7aaa9569129ed2880676eb04d9ab2512b66955fdfbdb4accfe963ddf079e3bbc9a14129bc2e0817412a2a90d4731431ac48abf1184d182d3f613935b0567935b8a363b20f05f085acf74f1c0049d70d296c62abebcd1bc8f4750bb50b2ce65ff8723f64a237fdf050fba6f1c29cf6d3f0587018b9b051bbe26a36da907037cf700e368f44bf29dcf41ccaa6abcdd8261cec15543 Never try to open it ...","link":"/2021/08/07/Interesting-Faults/"},{"title":"Introduction","text":"First of all, this is my first successful hexo Blog!I may be a pigeon in the future … u1s1 hexo is better than Gridea …And maybe I will put my Luogu Blog away qaq Test for Markdown &amp; LaTeX$$\\sum\\limits_{i=1}^na_i$$","link":"/2021/08/02/Introduction/"},{"title":"差分约束重提","text":"P5960 差分约束算法 显然题。 首先有 $x_{c1}-x_{c1’} \\le y_1$。那么有 $x_{c1} \\le x_{c1’} + y_1$。所以看到图论里面的松弛操作，即最终使得 dist[to]&lt;=dist[cur]+e[i].val。 要使得这个成立所以要跑一遍最短路。 那么将 $x$ 视为 dist，c1 视为 to，c1' 视为 cur 即可。 然后因为跑最短路的 dijkstra 需要源点，即单源最短路径。所以直接造一个源点就可以跑了，并没有什么实际作用（ 判负环似乎只需要加上一个统计入队次数的 cnt 即可。因为显然，有负环就没有合法解。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e3 + 10;int n, m, cnt; bool inq[N];int head[N&lt;&lt;1], dist[N], vis[N];struct Edge { int to, nxt, val;} e[N&lt;&lt;1];void addEdge(int u, int v, int w) { e[++cnt].to = v; e[cnt].nxt = head[u]; e[cnt].val = w; head[u] = cnt; return ;}bool spfa() { queue &lt;int&gt; sp; sp.push(0); vis[0] = 1, inq[0] = true; memset(dist, 0x3f, sizeof dist); dist[0] = 0; while (!sp.empty()) { int cur = sp.front(); sp.pop(); inq[cur] = false; for (int i=head[cur]; ~i; i=e[i].nxt) { int to = e[i].to; if (dist[to] &gt; dist[cur]+e[i].val) { dist[to] = dist[cur] + e[i].val; if (!inq[to]) { inq[to] = true, sp.push(to); ++vis[to]; if (vis[to]&gt;n) return true; } } } } return false;}int main() { memset(head, -1, sizeof head); cin &gt;&gt; n &gt;&gt; m; for (int i=1; i&lt;=m; ++i) { int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; addEdge(v, u, w); } for (int i=1; i&lt;=n; ++i) addEdge(0, i, 0); if (spfa()) { puts(&quot;NO&quot;); return 0; } for (int i=1; i&lt;=n; ++i) cout &lt;&lt; dist[i] &lt;&lt; ' '; return 0;}","link":"/2021/08/03/System-of-Difference-Constraints/"},{"title":"P2150 Solution","text":"P2150 寿司晚宴 Simplification for the Question 有 $[2,n]$ 总共 $n-1$ 个数。 从中挑选一些不重复的数字（可以不全选），组成集合 $S$ 和 $T$。 求使得 $\\forall x \\in S,y \\in T,\\gcd(x,y)=1$ 的方案总数。 Part 1 - 30pts Algorithm首先看到最简单的 30pts 算法，最暴力的部分总能给我们启示。 对于这 30pts，观察到 $n \\le 30$。 那么这意味着什么呢？对，就是暴力。 首先看到 $\\gcd$，求最大公约数，由唯一分解定理可知每一个数都可以由若干质数或质数的幂的连乘积构成，那么显然问题转化为：求使得 $\\forall x\\in S,y \\in T$，设 $x$ 包含的质数集合为 $P$，设 $y$ 包含的质数集合为 $P’$，有 $P∩P’=\\varnothing$，像这样的方案总数。 由于一个数的整数因数一定 $\\le$ 它本身，所以说最大的质数一定 $\\le n$，即 $p \\le n \\le 30$。其中 $p$ 表示当前情况的质数集合。 很显然，经过枚举，我们发现 $30$ 以内有 $10$ 个质数（ 所以直接暴力状压 DP，将质数的包含情况作为状态，包含为 $1$，否则为 $0$。 那么这个就是 30pts 的暴力算法了，时间复杂度 $\\Theta(2^{2p}N)$，其中 $p$ 为质数个数。 Part 2 - ? pts Algorithm我也不知道中间那两档分是用来干什么的。所以直接看正解算了吧。/kel Part 3 - 100pts Algorithm首先我们判一个数是否是质数，最暴力的是这样判的。 试除法 大概就长这样 12345function (int n)if n:0 / n:1 -&gt; back(0)for i in range(2,sqrt(n)) if !(n mod i) -&gt; back(0)back(1) 那么看到这个 $\\sqrt{n}$，这个就是解题的重点。 首先 $\\sqrt{n} \\times \\sqrt{n}=n$。 接着，分两种情况讨论质数 $p$。 $p\\ge\\sqrt{n}$ 那么设 $p \\times k=n$，则显然 $k \\le \\sqrt{n}$。 又因为因数不大于这个数本身，所以 $\\ge\\sqrt{n}$ 的数最多只有两个，即 $&gt;\\sqrt{n}$ 的数最多只有一个。 $p&lt;\\sqrt{n}$ 这个不用讲了吧。 那么又看到我们之前的暴力。 我们搞暴力，就是处理 $20$ 以内的质数。 但是现在我们发现 $&gt;\\sqrt{n}$ 的数最多只有一个，那么只要处理 $\\le \\sqrt{n}$ 的数，并且新开一个记录这个 $&gt;\\sqrt{n}$ 的数即可。 然后我们又看到 $n \\le 500$。 而 $\\sqrt{500}=22.360679775…$ 所以说这个暴力就是个铺垫嘛，处理 $22$ 反而只有八个质数。 所以我们就想到了正解，也就是，同样枚举八个质数的情况，然后再根据大质数来判断是否可选即可。 但是我们怎么能保证大质数呢？ 很显然，直接大质数从小到大结构体排个序即可。然后对于两个人取的 DP 数，直接暴力处理然后合并即可。 注意合并的时候要容斥，因为统计会同时处理两个人都不选的情况，所以在合并的时候要减掉一个原来的数值。 恭喜你，你又 A 掉了一道黑题。 时间复杂度优化为恒定 $\\Theta(2^{16}N)$ 其中有一个地方要注意一下，就是在判断一开始预处理的质数情况时，贡献一定要加到对面去而不是自己的地方，因为如果加到自己的地方，无法保证对面和自己没有重复的元素，但是因为我们已经判断过这个质数和自己的关系，所以即使这个质数情况与对面有重复，加到一起仍然与自己合法，因为一定不会有重复的地方。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;#define ri register intusing namespace std;const int N = 5e2 + 10;const int M = 1&lt;&lt;8;const int pr[8] = {2,3,5,7,11,13,17,19};int n, Mod, dp[M][M];int Mer1[M][M], Mer2[M][M];// Merge after dealing with, to DPvoid read(int &amp;ret) { ret = 0; char ch = getchar(); while (!isdigit(ch)) ch = getchar(); while (isdigit(ch)) { ret = (ret&lt;&lt;1) + (ret&lt;&lt;3) + (ch^48); ch = getchar(); } return ;}struct Number { int value; int MaxiPrime; int OtherPrime; void dealwith() { // deal with possible primes int cur = value; for (ri i=0; i&lt;8; ++i) { // choose the primes if (cur % pr[i]) continue; // can't be devided with no left OtherPrime |= (1&lt;&lt;i); while (!(cur % pr[i])) cur /= pr[i]; } if (cur &gt; 1) MaxiPrime = cur; return ; } bool operator &lt;(const Number &amp;X) const { return MaxiPrime &lt; X.MaxiPrime; }} a[N];void init() { read(n), read(Mod); for (ri i=2; i&lt;=n; ++i) a[i-1].value = i, a[i-1].dealwith(); sort(a+1, a+n), dp[0][0] = 1; return ;}void Merge(ri &amp;x, ri y) { x = (x + y) % Mod; return ;}int main() { init(); // predict: // Rolling Array, Back-to-Head Scan! for (ri i=1; i&lt;n; ++i) { if (i == 1 || a[i].MaxiPrime ^ a[i-1].MaxiPrime || !a[i].MaxiPrime) memcpy(Mer1, dp, sizeof Mer1), memcpy(Mer2, dp, sizeof Mer2); // just copy from dp to Merge for (ri j=M-1; j&gt;=0; --j) for (ri k=M-1; k&gt;=0; --k) { // enumarate each possible situation // which is of the two people if (j&amp;k) continue; // has the same elements if (!(j&amp;a[i].OtherPrime)) Merge(Mer1[j][k|a[i].OtherPrime], Mer1[j][k]); if (!(k&amp;a[i].OtherPrime)) Merge(Mer2[j|a[i].OtherPrime][k], Mer2[j][k]); # 需要注意的就是这里，不要写反了 } if (i == n-1 || a[i].MaxiPrime ^ a[i+1].MaxiPrime || !a[i].MaxiPrime) for (ri j=0; j&lt;M; ++j) for (ri k=0; k&lt;M; ++k) { if (j&amp;k) continue; // has the same elements ri to = Mer1[j][k] + Mer2[j][k] - dp[j][k]; to %= Mod, dp[j][k] = to; dp[j][k] = (dp[j][k] + Mod) % Mod; } } ri ans = 0; for (ri i=0; i&lt;M; ++i) for (ri j=0; j&lt;M; ++j) if (!(i&amp;j)) Merge(ans, dp[i][j]); cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2021/08/04/P2150-Solution/"},{"title":"Kill Network-Flows","text":"P2756 飞行员配对方案问题 只要默认前面 $m$ 个都是外国的，然后剩下的都是英国的，接着暴力建图跑 Dinic 即可。貌似只需要弄一个源点 $0$ 和汇点 $n+1$ 即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;const int N = 2e4 + 10;int n, m, cnt = 1;int head[N], dep[N];bool vis[N];struct Edge { int to, nxt, val;} e[N];void addEdge(int u, int v, int w) { e[++cnt].to = v; e[cnt].nxt = head[u]; e[cnt].val = w; head[u] = cnt; return ;}bool check() { for (int i=0; i&lt;=n+1; ++i) dep[i] = 0; dep[0] = 2; queue &lt;int&gt; sp; sp.push(0); while (!sp.empty()) { int cur = sp.front(); sp.pop(); for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (!dep[to] &amp;&amp; e[i].val) { dep[to] = dep[cur] + 1, sp.push(to); if (to==n+1) return true; } } } return false;}int dfs(int cur, int Max) { if (cur==n+1) return Max; int increase = Max; for (int i=head[cur]; i&amp;&amp;increase; i=e[i].nxt) { int to = e[i].to; if (e[i].val &amp;&amp; dep[to]==dep[cur]+1) { int res = dfs(to, min(increase, e[i].val)); e[i].val -= res, e[i^1].val += res; if (!res) dep[to] = 0; increase -= res; } } return Max-increase;}void read(int &amp;ret) { ret = 0; char ch = getchar(); int f = 1; while (!isdigit(ch) &amp;&amp; ch^'-') ch = getchar(); if (ch=='-') f = -1, ch = getchar(); while (isdigit(ch)) { ret = (ret&lt;&lt;1) + (ret&lt;&lt;3) + (ch^48); ch = getchar(); } ret *= f; return ;}int main() { read(m), read(n); while (1) { int u, v; read(u), read(v); if (u==-1 &amp;&amp; v==-1) break; addEdge(u, v, inf); addEdge(v, u, 0); } for (int i=1; i&lt;=m; ++i) addEdge(0, i, 1), addEdge(i, 0, 0); for (int i=m+1; i&lt;=n; ++i) addEdge(i, n+1, 1), addEdge(n+1, i, 0); int ans = 0; while(check()) ans += dfs(0, inf); cout &lt;&lt; ans &lt;&lt; endl; for (int i=2; i&lt;=cnt; i+=2) { if (!e[i^1].val) continue; if (!e[i].to || !e[i^1].to) continue; if (e[i].to==n+1) continue; if (e[i^1].to==n+1) continue; printf(&quot;%d %d\\n&quot;, e[i^1].to, e[i].to); } return 0;} P1251 餐巾计划问题 这道题最重要的是连边。那么很显然的拆点技巧，将一天拆成服务和收工两个点，即 i+N 和 i，后前两个点。那么源点为 0，汇点为 2*N+1。 要购买餐巾 显然从源点处购买，直接建边 add(0,i+N,inf,p)。 偷懒先不洗餐巾 显然直接延到下一天，add(i,i+1,inf,0)。 快洗 显然直接丢到 $m$ 天后，add(i,i+N+m,inf,f)。 慢洗 同理丢到 $n$ 天后，add(i,i+N+n,inf,s)。 然后每一天要跑至少为 r[i] 的流量，直接源点连收工，汇点连服务。 然后跑一遍最小费用最大流即可。 nt 的地方：DFS 要标记 cur，数组不要开小。要是写对了正解然后数组开小了那就真的是个 zz。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int MAXN = 2e3 + 10;const int inf = 2e9;int N, cnt = 1, head[MAXN*12];int p, m, f, n, s, dist[MAXN*12];bool inq[MAXN*2], vis[MAXN*2];int cost;struct Edge { int to, nxt, flow, val;} e[MAXN*12];void addEdge(int u, int v, int f, int w) { e[++cnt].to = v; e[cnt].nxt = head[u]; e[cnt].flow = f, e[cnt].val = w; head[u] = cnt; e[++cnt].to = u; e[cnt].nxt = head[v]; e[cnt].flow = 0, e[cnt].val = -w; head[v] = cnt; return ;}void read(int &amp;ret) { ret = 0; char ch = getchar(); while (!isdigit(ch)) ch = getchar(); while (isdigit(ch)) { ret = (ret&lt;&lt;1) + (ret&lt;&lt;3) + (ch^48); ch = getchar(); } return ;}bool spfa() { for (int i=0; i&lt;=2*N+1; ++i) dist[i] = inf, inq[i] = false; dist[0] = 0, inq[0] = true; queue &lt;int&gt; sp; sp.push(0); while (!sp.empty()) { int cur = sp.front(); sp.pop(); inq[cur] = false; for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (e[i].flow &amp;&amp; dist[to]&gt;dist[cur]+e[i].val) { dist[to] = dist[cur] + e[i].val; if (!inq[to]) inq[to] = true, sp.push(to); } } } return dist[2*N+1] &lt; inf;}int dfs(int cur, int Max) { if (cur == 2*N+1) { vis[cur] = true; return Max; } int increase = Max; vis[cur] = true; for (int i=head[cur]; i &amp;&amp; increase; i=e[i].nxt) { int to = e[i].to; if ((!vis[to] || to==MAXN) &amp;&amp; e[i].flow &amp;&amp; dist[to]==dist[cur]+e[i].val) { int res = dfs(to, min(increase, e[i].flow)); if (!res) continue; e[i].flow -= res, e[i^1].flow += res; cost += res * e[i].val, increase -= res; } } return Max-increase;}signed main() { cin &gt;&gt; N; for (int i=1; i&lt;=N; ++i) { int r; cin &gt;&gt; r; addEdge(0, i, r, 0); addEdge(i+N, 2*N+1, r, 0); } cin &gt;&gt; p &gt;&gt; m &gt;&gt; f &gt;&gt; n &gt;&gt; s; // begin point: i // ending point: i+N for (int i=1; i&lt;=N; ++i) { addEdge(0, i+N, inf, p); if (i&lt;N) addEdge(i, i+1, inf, 0); if (i+m&lt;=N) addEdge(i, i+N+m, inf, f); if (i+n&lt;=N) addEdge(i, i+N+n, inf, s); } while (spfa()) { for (int i=0; i&lt;=2*N+1; ++i) vis[i] = false; dfs(0, inf); } cout &lt;&lt; cost &lt;&lt; endl; return 0;} P4011 孤岛营救问题 这道题为什么要网络流啊。 难道不是直接暴力 BFS 寻找路径吗？ 直接状压一下钥匙，然后每一次到达门就看有没有钥匙就可以了。 nt 的地方：x(x), y(y) 写成了 x(x), y(x) … … 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 11;const int dx[] = {0, 1, 0, -1};const int dy[] = {1, 0, -1, 0};int n, m, p, k, s, door[N][N][N][N];int cnt[N][N], key[N][N][N];bool vis[N][N][1&lt;&lt;N];struct spread { int x, y, Key, cost; spread(int x, int y, int Key, int cost): x(x), y(y), Key(Key), cost(cost) {} spread() {}};int keyset(int x, int y) { int S = 0; for (int i=1; i&lt;=cnt[x][y]; ++i) S |= (1&lt;&lt;(key[x][y][i]-1)); return S;}bool check(int x, int y, int k, int st) { if (x&lt;1 || x&gt;n) return false; if (y&lt;1 || y&gt;m) return false; if (k&lt;0 || (k &amp;&amp; !(st&amp;(1&lt;&lt;(k-1))))) return false; return true;}int bfs() { int x = 1, y = 1; int S = keyset(x, y); queue &lt;spread&gt; que; que.push(spread(x, y, S, 0)); vis[x][y][S] = true; while (!que.empty()) { spread cur = que.front(); que.pop(); x = cur.x, y = cur.y, S = cur.Key; if (x==n &amp;&amp; y==m) return cur.cost; for (int i=0; i&lt;4; ++i) { int tox = x + dx[i], toy = y + dy[i]; int Door = door[x][y][tox][toy]; if (!check(tox, toy, Door, S)) continue; int to = S|keyset(tox, toy); if (vis[tox][toy][to]) continue; vis[tox][toy][to] = true; que.push(spread(tox, toy, to, cur.cost+1)); } } return -1;}int main() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; p &gt;&gt; k; while (k--) { int x, y, X, Y, G; cin &gt;&gt; x &gt;&gt; y &gt;&gt; X &gt;&gt; Y &gt;&gt; G; if (G) door[x][y][X][Y] = door[X][Y][x][y] = G; else door[x][y][X][Y] = door[X][Y][x][y] = -1; } cin &gt;&gt; s; while (s--) { int x, y, Q; cin &gt;&gt; x &gt;&gt; y &gt;&gt; Q; key[x][y][++cnt[x][y]] = Q; } cout &lt;&lt; bfs() &lt;&lt; endl; return 0;} P2764 最小路径覆盖问题 众所周知最小路径覆盖 $=$ 顶点数 $-$ 最大匹配数，这个是很显然的。 Proof：因为对于每一个点一开始都可以作为一条路径，所以一开始就有 $n$ 条路径。因为每一次匹配相当于把两个点合并，所以路径条数相当于减掉了 $1$，所以最大匹配数就是合并的个数，所以最后就是 $n-$最大匹配数。又因为二分图可以网络流乱搞，所以路径覆盖也可以网络流乱搞。 所以正常的 trick，拆点跑最大流。路径输出比较正常，直接在 DFS 的时候找到起始点然后记录路径即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;void read(int &amp;ret) { ret = 0; char ch = getchar(); while (!isdigit(ch)) ch = getchar(); while (isdigit(ch)) { ret = (ret&lt;&lt;1) + (ret&lt;&lt;3) + (ch^48); ch = getchar(); } return ;}const int N = 1e5 + 10;const int inf = 1e9;int n, m, s, t, cnt = 1;int dep[N], head[N]; bool inq[N];int cost, path[N]; bool vis[N];struct Edge { int to, nxt, flow;} e[N];void addEdge(int u, int v, int f) { e[++cnt].to = v; e[cnt].nxt = head[u]; e[cnt].flow = f; head[u] = cnt; e[++cnt].to = u; e[cnt].nxt = head[v]; e[cnt].flow = 0; head[v] = cnt; return ;}bool check() { for (int i=0; i&lt;=t; ++i) dep[i] = inf, inq[i] = false; dep[s] = 0; queue &lt;int&gt; sp; sp.push(s); inq[s] = true; while (!sp.empty()) { int cur = sp.front(); sp.pop(); for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (e[i].flow &amp;&amp; dep[to]==inf) { dep[to] = dep[cur] + 1, sp.push(to); } } } return dep[t] ^ inf;}int dfs(int cur, int Max) { if (cur==t) return Max; int increase = Max; for (int i=head[cur]; i &amp;&amp; increase; i=e[i].nxt) { int to = e[i].to; if (e[i].flow &amp;&amp; dep[to]==dep[cur]+1) { int res = dfs(to, min(increase, e[i].flow)); if (!res) { dep[to] = -1; continue; } e[i].flow -= res, e[i^1].flow += res; path[cur] = to; if (cur) vis[to-n] = true; increase -= res; } } return Max-increase;}int main() { cin &gt;&gt; n &gt;&gt; m; t = 2*n+1; for (int i=1; i&lt;=m; ++i) { int u, v; cin &gt;&gt; u &gt;&gt; v; addEdge(u, n+v, 1); } for (int i=1; i&lt;=n; ++i) addEdge(s, i, 1); for (int i=1; i&lt;=n; ++i) addEdge(i+n, t, 1); int ans = 0; while (check()) ans += dfs(s, inf); for (int i=1; i&lt;=n; ++i) { if (vis[i]) continue; int cur = i; cout &lt;&lt; i; while(path[cur] &amp;&amp; path[cur]^t) cout &lt;&lt; ' ' &lt;&lt; path[cur]-n, cur = path[cur]-n; cout &lt;&lt; endl; } cout &lt;&lt; n-ans &lt;&lt; endl; return 0;} P4016 负载平衡问题 听名字还挺高大上的。 其实就是个卡牌游戏啊，只不过每一次只可以交换环上相邻两个。那么直接断环成链，拿原数减掉最后的固定答案然后前缀和加到 ans。 顺带卡了下常，12ms 最优解 Rank1。 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;int n, sum, ans, a[110], Sum[110];int abs(int x) { return x&gt;0? x:-x; }void qsort(int l, int r) { int mid = Sum[(l+r)&gt;&gt;1]; int i=l, j=r; do { while (Sum[i]&lt;mid) ++i; while (Sum[j]&gt;mid) --j; if(i&lt;=j) { int u=Sum[i]; Sum[i]=Sum[j]; Sum[j]=u; i++, j--; } } while (i&lt;=j); if (l&lt;j) qsort(l, j); if (i&lt;r) qsort(i, r); return ;}int main() { scanf(&quot;%d&quot;, &amp;n); for (int i=1; i&lt;=n; ++i) scanf(&quot;%d&quot;, &amp;a[i]), sum += a[i]; sum /= n; for (int i=1; i&lt;=n; ++i) Sum[i] = Sum[i-1]+a[i]-sum, a[i] = Sum[i]; qsort(1, n); int mid = n/2+1; for (int i=1; i&lt;=n; ++i) ans += abs(Sum[mid]-Sum[i]); printf(&quot;%d\\n&quot;, ans); return 0;} UVA11380 Down Went The Titanic 简单题。 首先看到点有限制，直接拆点。 那么因为没有给出单源点和汇点，分别建一个。 接着可以将 * 视为连向源点，所以边权为 $1$。同理 # 视为连向汇点，边权为限制 $p$。 然后因为 . 只能踩一次，所以拆成两个点，两个点之间的限制为 $1$。@ 可以踩无数次，所以连 INF。 接着因为周边四个点都可以扩展到（除起始点和水显然不可以扩展）。所以连容量为 INF 的边。 然后跑一遍最大流。 记得多测 cnt 要赋成 $1$ 而不是 $0$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 10;const int inf = 1e9;const int dx[4] = {1, 0, -1, 0};const int dy[4] = {0, 1, 0, -1};int n, m, p, s, t, cnt = 1;int dep[N], head[N]; char ch[40][40];struct Edge { int to, nxt, flow;} e[N];void addEdge(int u, int v, int f) { e[++cnt].to = v, e[cnt].nxt = head[u]; e[cnt].flow = f, head[u] = cnt; e[++cnt].to = u, e[cnt].nxt = head[v]; e[cnt].flow = 0, head[v] = cnt;}bool check(int x, int y) { return x&lt;1 || x&gt;n || y&lt;1 || y&gt;m;}void init() { cnt = 1; t = 2*n*m + 1; for (int i=1; i&lt;=n; ++i) for (int j=1; j&lt;=m; ++j) cin &gt;&gt; ch[i][j]; memset(head, -1, sizeof head); return ;}int id(int x, int y) { return (x-1)*m+y; }bool spfa() { for (int i=s; i&lt;=t; ++i) dep[i] = inf; dep[s] = 0; queue &lt;int&gt; sp; sp.push(s); while (!sp.empty()) { int cur = sp.front(); sp.pop(); for (int i=head[cur]; ~i; i=e[i].nxt) { int to = e[i].to; if (e[i].flow &amp;&amp; dep[to]==inf) { dep[to] = dep[cur] + 1, sp.push(to); } } } return dep[t]^inf;}int dfs(int cur, int Max) { if (cur==t) return Max; int increase = Max; for (int i=head[cur]; ~i &amp;&amp; increase; i=e[i].nxt) { int to = e[i].to; if (e[i].flow &amp;&amp; dep[to]==dep[cur]+1) { int res = dfs(to, min(increase, e[i].flow)); if (!res) continue; e[i].flow -= res, e[i^1].flow += res; increase -= res; } } return Max-increase;}int main() { while (scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;p) != EOF) { init(); int siz = n*m; for (int i=1; i&lt;=n; ++i) { for (int j=1; j&lt;=m; ++j) { if (ch[i][j] == '~') continue; if (ch[i][j] == '*') addEdge(s, id(i,j), 1); if (ch[i][j] == '.') addEdge(id(i,j), id(i,j)+siz, 1); if (ch[i][j] == '#') addEdge(id(i,j), t, p); for (int k=0; k&lt;4; ++k) { int tox = i+dx[k], toy = j+dy[k]; if (check(tox, toy)) continue; if (ch[tox][toy] == '*' || ch[tox][toy] == '~') continue; if (ch[i][j] == '.') addEdge(id(i,j)+siz, id(tox, toy), inf); else addEdge(id(i,j), id(tox, toy), inf); } } } int ans = 0; while (spfa()) ans += dfs(s, inf); cout &lt;&lt; ans &lt;&lt; endl; } return 0;} P3965 循环格 这题也是个拆点模板。首先 S 连向出点，T 连向入点，默认已经拆完点。所以因为要使得成为循环格，所以要进行两两之间点的匹配。即入度、出度均为 $1$。 所以跑二分图匹配最小费用即可。建边的 value 只需要看当前点实际指的方向是否是枚举的方向。如果是费用为 $0$，否则为 $1$。 最后要注意：cnt 要赋成 $1$！！11 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e4 + 10;const int inf = 114514;int n, m, s, t, cnt = 1, cost;int dist[N], head[N];bool vis[N], inq[N];char Map[20][20]; int To[20][20];const int dx[] = {0, 0, -1, 1};const int dy[] = {-1, 1, 0, 0};struct Edge { int to, nxt, flow, val;} e[N];void addEdge(int u, int v, int f, int w) { e[++cnt].to = v, e[cnt].nxt = head[u]; e[cnt].flow = f, e[cnt].val = w, head[u] = cnt; e[++cnt].to = u, e[cnt].nxt = head[v]; e[cnt].flow = 0, e[cnt].val = -w, head[v] = cnt; return ;}bool spfa() { for (int i=s; i&lt;=t; ++i) inq[i] = false, dist[i] = inf; dist[s] = 0, inq[s] = true; queue &lt;int&gt; sp; sp.push(s); while (!sp.empty()) { int cur = sp.front(); sp.pop(); inq[cur] = false; for (int i=head[cur]; ~i; i=e[i].nxt) { int to = e[i].to; if (e[i].flow &amp;&amp; dist[to]&gt;dist[cur]+e[i].val) { dist[to] = dist[cur] + e[i].val; if (!inq[to]) { inq[to] = true; sp.push(to); } } } } return dist[t]^inf;}int dfs(int cur, int Max) { vis[cur] = true; if (cur==t) return Max; int increase = Max; for (int i=head[cur]; ~i &amp;&amp; increase; i=e[i].nxt) { int to = e[i].to; if ((!vis[to]||to==t) &amp;&amp; e[i].flow &amp;&amp; dist[to]==dist[cur]+e[i].val) { int res = dfs(to, min(increase, e[i].flow)); if (!res) continue; e[i].flow -= res, e[i^1].flow += res; increase -= res, cost += res * e[i].val; } } return Max-increase;}int id(int x, int y) { return (x-1)*m+y; }int main() { memset(head, -1, sizeof head); cin &gt;&gt; n &gt;&gt; m; t = 2*n*m + 1; for (int i=1; i&lt;=n; ++i) for (int j=1; j&lt;=m; ++j) { cin &gt;&gt; Map[i][j]; if (Map[i][j]=='L') To[i][j] = 0; if (Map[i][j]=='R') To[i][j] = 1; if (Map[i][j]=='U') To[i][j] = 2; if (Map[i][j]=='D') To[i][j] = 3; } for (int i=1; i&lt;=n; ++i) { for (int j=1; j&lt;=m; ++j) { for (int k=0; k&lt;4; ++k) { int tox = i+dx[k], toy = j+dy[k]; if (tox&lt;1) tox = n; if (tox&gt;n) tox = 1; if (toy&lt;1) toy = m; if (toy&gt;m) toy = 1; addEdge(id(i,j)+n*m, id(tox, toy), 1, k!=To[i][j]); } } } for (int i=1; i&lt;=n; ++i) for (int j=1; j&lt;=m; ++j) { addEdge(s, id(i,j)+n*m, 1, 0); addEdge(id(i,j), t, 1, 0); } int ans = 0; while (spfa()) { for (int i=s; i&lt;=t; ++i) vis[i] = false; ans += dfs(s, inf); } cout &lt;&lt; cost &lt;&lt; endl; return 0;}","link":"/2021/08/02/Kill-Network-Flows/"},{"title":"DS On Tree","text":"P3384 轻重链剖分 显然的板子题。 那么我们只需要干这样一件事情，就是按照重儿子的顺序来进行 DFS，那么这样我们就可以通过 DFS 序这样一个东西来进行子树的查询和更改，同时也可以通过跳链顶，类似 LCA 的操作，来进行路径的修改和查询。这都非常容易实现。 同时有几个我容易犯错的地方。 树剖几大毒瘤问题 if(dep[tp[l]] &lt; dep[tp[r]]) swap(l, r);这个很显然，因为树剖是按照 tp-&gt;node 的顺序所以是 tp 来 swap。 upd(1, 1, n, id[tp[l]], id[l], f);我也不知道我为什么 id[l] 能够写成 tp[l]。 搞线段树的时候要注意 pushdown 的灵活变通，不要把修改值弄成了加法和乘法。 所以代码会长下面这样。顺带一提，这是我重写了几万遍之后确定的样式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 1e5 + 10;int n, m, root, Mod, cnt, idx;int w[N], wl[N], val[N&lt;&lt;2], head[N&lt;&lt;1];int dep[N], id[N], fa[N], son[N];int lazy[N&lt;&lt;2], tp[N], siz[N];struct Edge { int to, nxt;} e[N&lt;&lt;1];void addEdge(int u, int v) { e[++cnt].to = v; e[cnt].nxt = head[u]; head[u] = cnt; return ;}#define ls ((rt)&lt;&lt;1)#define rs ((rt)&lt;&lt;1|1)void read(int &amp;ret) { ret = 0; char ch = getchar(); while (!isdigit(ch)) ch = getchar(); while (isdigit(ch)) { ret = (ret&lt;&lt;1) + (ret&lt;&lt;3) + (ch^48); ch = getchar(); } return ;}void pushup(int rt) { val[rt] = (val[ls] + val[rs]) % Mod; return ;}void build(int rt, int l, int r) { if (l==r) { val[rt] = wl[l]; return ; } int mid = (l+r) &gt;&gt; 1; build(ls, l, mid); build(rs, mid+1, r); pushup(rt); return ;}void pushdown(int rt, int l, int r) { if (!lazy[rt]) return ; int mid = (l+r) &gt;&gt; 1; lazy[ls] += lazy[rt], lazy[rs] += lazy[rt]; lazy[ls] %= Mod, lazy[rs] %= Mod; val[ls] = (val[ls] + (mid-l+1) * lazy[rt]) % Mod; val[rs] = (val[rs] + (r-mid) * lazy[rt]) % Mod; lazy[rt] = 0; return ;}void upd(int rt, int l, int r, int L, int R, int f) { if (L&lt;=l &amp;&amp; r&lt;=R) { val[rt] += (r-l+1) * f, val[rt] %= Mod; lazy[rt] += f, lazy[rt] %= Mod; return ; } pushdown(rt, l, r); int mid = (l+r) &gt;&gt; 1; if (L&lt;=mid) upd(ls, l, mid, L, R, f); if (R&gt;mid) upd(rs, mid+1, r, L, R, f); pushup(rt); return ;}int query(int rt, int l, int r, int L, int R) { if (L&lt;=l &amp;&amp; r&lt;=R) return val[rt]; pushdown(rt, l, r); int mid = (l+r) &gt;&gt; 1, ans = 0; if (L&lt;=mid) ans += query(ls, l, mid, L, R); if (R&gt;mid) ans += query(rs, mid+1, r, L, R); return ans % Mod;}void dfs1(int cur, int f) { dep[cur] = dep[f] + 1; siz[cur] = 1, fa[cur] = f; int heavyson = -1; for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (to==f) continue; dfs1(to, cur), siz[cur] += siz[to]; if (siz[to]&gt;heavyson) heavyson = siz[to], son[cur] = to; } return ;}void dfs2(int cur, int Tp) { id[cur] = ++idx, wl[idx] = w[cur]; tp[cur] = Tp; if (!son[cur]) return ; dfs2(son[cur], Tp); for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (to==son[cur] || to==fa[cur]) continue; dfs2(to, to); } return ;}void up(int l, int r, int f) { f %= Mod; while (tp[l] ^ tp[r]) { if (dep[tp[l]] &lt; dep[tp[r]]) swap(l, r); upd(1, 1, n, id[tp[l]], id[l], f); l = fa[tp[l]]; } if (dep[l] &gt; dep[r]) swap(l, r); upd(1, 1, n, id[l], id[r], f); return ;}int qu(int l, int r) { int ans = 0; while (tp[l] ^ tp[r]) { if (dep[tp[l]] &lt; dep[tp[r]]) swap(l, r); ans = (ans + query(1, 1, n, id[tp[l]], id[l])) % Mod; l = fa[tp[l]]; } if (dep[l] &gt; dep[r]) swap(l, r); ans = (ans + query(1, 1, n, id[l], id[r])) % Mod; return ans;}void upsub(int x, int f) { upd(1, 1, n, id[x], id[x]+siz[x]-1, f); }int qusub(int x) { return query(1, 1, n, id[x], id[x]+siz[x]-1); }signed main() { read(n), read(m); read(root), read(Mod); for (int i=1; i&lt;=n; ++i) read(w[i]); for (int i=1; i&lt;n; ++i) { int u, v; read(u), read(v); addEdge(u, v); addEdge(v, u); } dfs1(root, root); dfs2(root, 0); build(1, 1, n); while (m--) { int opt, x, y, z; read(opt); if (opt==1) { read(x), read(y), read(z); up(x, y, z); } else if (opt==2) { read(x), read(y); printf(&quot;%lld\\n&quot;, qu(x, y) % Mod); } else if (opt==3) { read(x), read(z); upsub(x, z); } else { read(x); printf(&quot;%lld\\n&quot;, qusub(x) % Mod); } } return 0;} P2590 树的统计 更简单了，甚至不需要 lazytag。 代码如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;stdio.h&gt;#include &lt;iostream&gt;#define isdigit(ch) (ch&gt;47&amp;&amp;ch&lt;58)void read(int &amp;ret) { ret = 0; char ch = getchar(); int f = 1; while (!isdigit(ch) &amp;&amp; ch ^ '-') ch = getchar(); if (ch == '-') f = -1, ch = getchar(); while (isdigit(ch)) { ret = (ret&lt;&lt;1) + (ret&lt;&lt;3) + (ch^48); ch = getchar(); } ret *= f; return ;}void out(int ret) { if (ret&lt;0) { ret = -ret, putchar('-'); } if (ret&gt;9) out(ret/10); putchar(ret%10 ^ 48); return ;}const int N = 3e4 + 10;int n, Q, cnt, dfn;int w[N], v[N], head[N];int val[N&lt;&lt;2], siz[N], Maxi[N&lt;&lt;2];int id[N], fa[N], tp[N], son[N], dep[N];char str[10];int max(int x, int y) { return x&gt;y? x:y; }void swap(int &amp;x, int &amp;y) { x ^= y ^= x ^= y; }struct Edge { int to, nxt;} e[N&lt;&lt;1];#define ls ((rt)&lt;&lt;1)#define rs ((rt)&lt;&lt;1|1)void addEdge(int u, int v) { e[++cnt].to = v; e[cnt].nxt = head[u]; head[u] = cnt; return ;}void pushup(int rt) { val[rt] = val[ls] + val[rs]; Maxi[rt] = max(Maxi[ls], Maxi[rs]); return ;}void build(int rt, int l, int r) { if (l == r) { val[rt] = Maxi[rt] = v[l]; return ; } int mid = (l+r) &gt;&gt; 1; build(ls, l, mid); build(rs, mid+1, r); pushup(rt); return ;}void upd(int rt, int l, int r, int pos, int f) { if (l == r) { val[rt] = Maxi[rt] = f; return ; } int mid = (l+r) &gt;&gt; 1; if (pos&lt;=mid) upd(ls, l, mid, pos, f); if (pos&gt;mid) upd(rs, mid+1, r, pos, f); pushup(rt); return ;}int querys(int rt, int l, int r, int L, int R) { if (L&lt;=l &amp;&amp; r&lt;=R) return val[rt]; int mid = (l+r) &gt;&gt; 1, ans = 0; if (L&lt;=mid) ans += querys(ls, l, mid, L, R); if (R&gt;mid) ans += querys(rs, mid+1, r, L, R); return ans;}int querym(int rt, int l, int r, int L, int R) { if (L&lt;=l &amp;&amp; r&lt;=R) return Maxi[rt]; int mid = (l+r) &gt;&gt; 1, Max = -1e9; if (L&lt;=mid) Max = max(Max, querym(ls, l, mid, L, R)); if (R&gt;mid) Max = max(Max, querym(rs, mid+1, r, L, R)); return Max;}void dfs1(int cur, int Fa) { dep[cur] = dep[Fa] + 1; fa[cur] = Fa, siz[cur] = 1; int heavyson = -1; for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (to == Fa) continue; dfs1(to, cur); siz[cur] += siz[to]; if (siz[to] &gt; heavyson) son[cur] = to, heavyson = siz[to]; } return ;}void dfs2(int cur, int Tp) { id[cur] = ++dfn; v[dfn] = w[cur], tp[cur] = Tp; if (!son[cur]) return ; dfs2(son[cur], Tp); for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (to == fa[cur] || to == son[cur]) continue; dfs2(to, to); } return ;}int qus(int l, int r) { int ans = 0; while (tp[l] ^ tp[r]) { if (dep[tp[l]] &lt; dep[tp[r]]) swap(l, r); int cur = querys(1, 1, n, id[tp[l]], id[l]); ans += cur, l = fa[tp[l]]; } if (dep[l] &gt; dep[r]) swap(l, r); ans += querys(1, 1, n, id[l], id[r]); return ans;}int qum(int l, int r) { int ans = -1e9; while (tp[l] ^ tp[r]) { if (dep[tp[l]] &lt; dep[tp[r]]) swap(l, r); int cur = querym(1, 1, n, id[tp[l]], id[l]); ans = max(ans, cur), l = fa[tp[l]]; } if (dep[l] &gt; dep[r]) swap(l, r); ans = max(ans, querym(1, 1, n, id[l], id[r])); return ans;}int main() {// freopen(&quot;P2590.in&quot;, &quot;r&quot;, stdin);// freopen(&quot;P2590.out&quot;, &quot;w&quot;, stdout); read(n); for (int i=1; i&lt;n; ++i) { int x, y; read(x), read(y); addEdge(x, y), addEdge(y, x); } for (int i=1; i&lt;=n; ++i) read(w[i]); dfs1(1, 1), dfs2(1, 1); build(1, 1, n); read(Q); while (Q--) { std::cin &gt;&gt; str+1; int l, r; read(l), read(r); if (str[1] == 'C') upd(1, 1, n, id[l], r); else if (str[2] == 'M') out(qum(l, r)), puts(&quot;&quot;); else if (str[2] == 'S') out(qus(l, r)), puts(&quot;&quot;); } return 0;} P2146 软件包管理器 简单 trick。 只需要将依赖关系转化为树上关系就可以了。然后就是要区分 0 和 unedited，完全不一样。所以可以直接将 unedited 设置为 -1 然后乱搞即可。 注意是赋值而不是加法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;bits/stdc++.h&gt;using namespace std;void read(int &amp;ret) { ret = 0; char ch = getchar(); while (!isdigit(ch)) ch = getchar(); while (isdigit(ch)) { ret = (ret&lt;&lt;1) + (ret&lt;&lt;3) + (ch^48); ch = getchar(); } return ;}const int N = 1e5 + 10;int n, Q, cnt, idx, head[N];int val[N&lt;&lt;2], lazy[N&lt;&lt;2];int id[N], tp[N], siz[N], dep[N];char opt[20]; int fa[N], son[N];struct Edge { int to, nxt; } e[N];void addEdge(int u, int v) { e[++cnt].to = v; e[cnt].nxt = head[u]; head[u] = cnt; return ;}#define ls ((rt)&lt;&lt;1)#define rs ((rt)&lt;&lt;1|1)void pushup(int rt) { val[rt] = val[ls] + val[rs]; return ;}void pushdown(int rt, int l, int r) { if (lazy[rt]&lt;0) return ; int mid = (l+r) &gt;&gt; 1; lazy[ls] = lazy[rt], lazy[rs] = lazy[rt]; val[ls] = lazy[rt] * (mid-l+1); val[rs] = lazy[rt] * (r-mid); lazy[rt] = -1; return ;}void upd(int rt, int l, int r, int L, int R, int f) { if (L&lt;=l &amp;&amp; r&lt;=R) { lazy[rt] = f; val[rt] = f * (r-l+1); return ; } pushdown(rt, l, r); int mid = (l+r) &gt;&gt; 1; if (L&lt;=mid) upd(ls, l, mid, L, R, f); if (R&gt;mid) upd(rs, mid+1, r, L, R, f); pushup(rt); return ;}int query(int rt, int l, int r, int L, int R) { if (L&lt;=l &amp;&amp; r&lt;=R) return val[rt]; pushdown(rt, l, r); int mid = (l+r) &gt;&gt; 1, ans = 0; if (L&lt;=mid) ans += query(ls, l, mid, L, R); if (R&gt;mid) ans += query(rs, mid+1, r, L, R); return ans;}void dfs1(int cur, int f) { dep[cur] = dep[f] + 1; fa[cur] = f, siz[cur] = 1; int heavyson = -1; for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; dfs1(to, cur), siz[cur] += siz[to]; if (siz[to] &gt; heavyson) heavyson = siz[to], son[cur] = to; } return ;}void dfs2(int cur, int Tp) { id[cur] = ++idx; tp[cur] = Tp; if (!son[cur]) return ; dfs2(son[cur], Tp); for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (to==son[cur]) continue; dfs2(to, to); } return ;}void up(int l, int r, int f) { while (tp[l] ^ tp[r]) { if (dep[tp[l]] &lt; dep[tp[r]]) swap(l, r); upd(1, 1, n, id[tp[l]], id[l], f); l = fa[tp[l]]; } if (dep[l] &gt; dep[r]) swap(l, r); upd(1, 1, n, id[l], id[r], f); return ;}int main() {// freopen(&quot;P2146.in&quot;, &quot;r&quot;, stdin); memset(lazy, -1, sizeof lazy); read(n); for (int i=2; i&lt;=n; ++i) { int v; read(v); addEdge(v+1, i); } dfs1(1, 1), dfs2(1, 1), read(Q); while (Q--) { cin &gt;&gt; opt+1; int v; read(v); ++v; int cur = query(1, 1, n, 1, n); if (opt[1]=='i') up(1, v, 1); else if (opt[1]=='u') upd(1, 1, n, id[v], id[v]+siz[v]-1, 0); int to = query(1, 1, n, 1, n); printf(&quot;%d\\n&quot;, abs(cur-to)); } return 0;} P3178 树上操作 也是个简单题，就是不要被 from 和 to 骗了，双向边肯定要连的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;void read(int &amp;ret) { ret = 0; char ch = getchar(); int f = 1; while (!isdigit(ch) &amp;&amp; ch^'-') ch = getchar(); if (ch=='-') f = -1, ch = getchar(); while (isdigit(ch)) { ret = (ret&lt;&lt;1) + (ret&lt;&lt;3) + (ch^48); ch = getchar(); } ret *= f; return ;}const int N = 1e5 + 10;int n, m, cnt, idx;int dep[N], son[N], fa[N], siz[N];int head[N&lt;&lt;1], tp[N], w[N], wl[N], id[N];struct Edge { int to, nxt; } e[N&lt;&lt;1];void addEdge(int u, int v) { e[++cnt].to = v; e[cnt].nxt = head[u]; head[u] = cnt; return ;}int lazy[N&lt;&lt;2], val[N&lt;&lt;2];#define ls ((rt)&lt;&lt;1)#define rs ((rt)&lt;&lt;1|1)void pushup(int rt) { val[rt] = val[ls] + val[rs]; return ;}void build(int rt, int l, int r) { if (l==r) { val[rt] = wl[l]; return ; } int mid = (l+r) &gt;&gt; 1; build(ls, l, mid); build(rs, mid+1, r); pushup(rt); return ;}void pushdown(int rt, int l, int r) { if (!lazy[rt]) return ; int mid = (l+r) &gt;&gt; 1; lazy[ls] += lazy[rt], lazy[rs] += lazy[rt]; val[ls] += (mid-l+1) * lazy[rt]; val[rs] += (r-mid) * lazy[rt]; lazy[rt] = 0; return ;}void upd(int rt, int l, int r, int L, int R, int f) { if (L&lt;=l &amp;&amp; r&lt;=R) { lazy[rt] += f; val[rt] += f * (r-l+1); return ; } int mid = (l+r) &gt;&gt; 1; pushdown(rt, l, r); if (L&lt;=mid) upd(ls, l, mid, L, R, f); if (R&gt;mid) upd(rs, mid+1, r, L, R, f); pushup(rt); return ;}int query(int rt, int l, int r, int L, int R) { if (L&lt;=l &amp;&amp; r&lt;=R) return val[rt]; int ans = 0, mid = (l+r) &gt;&gt; 1; pushdown(rt, l, r); if (L&lt;=mid) ans += query(ls, l, mid, L, R); if (R&gt;mid) ans += query(rs, mid+1, r, L, R); return ans;}void dfs1(int cur, int f) { fa[cur] = f, siz[cur] = 1; dep[cur] = dep[f] + 1; int heavyson = -1; for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (to==f) continue; dfs1(to, cur); siz[cur] += siz[to]; if (siz[to] &gt; heavyson) heavyson = siz[to], son[cur] = to; } return ;}void dfs2(int cur, int Tp) { id[cur] = ++idx, wl[idx] = w[cur]; tp[cur] = Tp; if (!son[cur]) return ; dfs2(son[cur], Tp); for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (to==fa[cur] || to==son[cur]) continue; dfs2(to, to); } return ;}int que(int l, int r) { int ans = 0; while (tp[l] ^ tp[r]) { if (dep[tp[l]] &lt; dep[tp[r]]) swap(l, r); ans += query(1, 1, n, id[tp[l]], id[l]); l = fa[tp[l]]; } if (dep[l] &gt; dep[r]) swap(l, r); ans += query(1, 1, n, id[l], id[r]); return ans;}signed main() { read(n), read(m); for (int i=1; i&lt;=n; ++i) read(w[i]); for (int i=1; i&lt;n; ++i) { int u, v; read(u), read(v); addEdge(u, v); addEdge(v, u); } dfs1(1, 1), dfs2(1, 1); build(1, 1, n); while (m--) { int opt, x, a; read(opt), read(x); if (opt==1) { read(a); upd(1, 1, n, id[x], id[x], a); } else if (opt==2) { read(a); upd(1, 1, n, id[x], id[x]+siz[x]-1, a); } else printf(&quot;%lld\\n&quot;, que(1, x)); } return 0;} P7735 轻重边 毒瘤出题人搞边不搞点。 看到题目首先想到树链剖分。首先变为重边的操作不难，直接普通树链剖分即可。查询路径上包含所有重边也很简单，只需要标记为 1 然后统计和。 但是 ex 的在于将点 $x$ 的所有连边变为轻边。 所以应该怎么弄呢？那么很容易想到树链剖分的染色。 可以这样做：每一次路径变为重边就可以看成是给路径上所有点染一种 新的 颜色。那么这个时候，看到所有其他连边连向的点都和当前路径上点的颜色不一样。这个时候就可以默认其变为了轻边。 所以这样就可以得出判断轻边的条件了。就是一条边，如果它两端颜色相同就为重边。证明显然。 然后就是关于区间修改的问题了。因为当前是求区间两端颜色相同边的个数，所以考虑树链剖分，将一段路径拆成若干区间，每一次合并区间都可以加上子区间答案，并保证其正确性，显而易见这样是不会假掉的。要注意的就是如果子区间中间连接的两点颜色相同答案要加上 $1$。 那路径修改呢？这样还是有很大区别的。因为两点之间路径可以视作从一个点剖开变成两条路径。所以考虑两条路径分别维护。 那么我们可以对于每一个跳链顶的过程，记录当前 update 的是以 $u$ 为起点的路径还是以 $v$ 为起点的路径（$u \\rightarrow v$ 为路径），每一次看维护两个指针 L 和 R 是否交换即可，最后还要合并答案，这里还是要详细讲一下。 不考虑整条路径两个指针 L，R 的实际位置，只考虑相对位置。那么有两种情况。 L 跳到了但是 R 没有跳到。 显然这个时候 dep[L]&lt;dep[R]。又因为 L 跳到了，所以上一次更新的是 L 路径，本次就要更新 R 路径了。所以本轮不用交换 L 和 R，L 路径和 R 路径的 tag 仍然指向 L。这里就是容易弄混的地方，指向 L 的 tag 在这时要更新 R 路径。 R 跳到了但是 L 没有跳到。 显然这个时候 dep[L]&gt;dep[R]。又因为 R 跳到了，所以上面的 tag 指向 R，本次更新 L 路径。因为当前这样所以要交换 L 和 R，tag 反转之后指向当前 R，所以相当于更新交换之后的 R 路径，本质还是 L 路径。（我自己都晕了）反正不偷懒的写法会好理解一些，手动模拟比较好一点。 大概就是分 L 先到和 R 先到的情况吧。其实手玩一下也是没有问题的，手玩完之后再写暴力更新的代码。 另外一点，我这里默认 L 路径在左边，其 dep[l]&gt;dep[r]。而 R 路径默认在右边，其 dep[l]&lt;dep[r]。 lc 和 rc 分别是 leftcolor，rightcolor。 注意一开始如果全部没有染色那默认全都为 $0$，那么重边的条数就变成 $n-1$ 了，which is totally wrong。所以一开始就要染奇奇怪怪的颜色。接着注意边数等于点数减一，在 pushdown 和 update 的时候要注意。 代码如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;int T, n, m, cnt, idx, lazy[N&lt;&lt;2];int head[N&lt;&lt;1], dep[N], siz[N];int tp[N], son[N], fa[N], id[N];struct Edge { int to, nxt; } e[N&lt;&lt;1];struct seg { int lc, rc, val; seg(int lc, int rc, int val): lc(lc), rc(rc), val(val) {} seg() {}} tree[N&lt;&lt;2];#define ls ((rt)&lt;&lt;1)#define rs ((rt)&lt;&lt;1|1)void pushup(int rt) { tree[rt].lc = tree[ls].lc; tree[rt].rc = tree[rs].rc; tree[rt].val = tree[ls].val + tree[rs].val; if (tree[ls].rc == tree[rs].lc) ++tree[rt].val; return ;}seg Merge(seg L, seg R) { seg cur; cur.lc = L.lc, cur.rc = R.rc; cur.val = L.val + R.val; if (L.rc == R.lc) ++cur.val; return cur;}void pushdown(int rt, int l, int r) { // lazy[rt] -&gt; stores the color if (!lazy[rt]) return ; int mid = (l+r) &gt;&gt; 1; lazy[ls] = lazy[rs] = lazy[rt]; tree[ls] = seg(lazy[rt], lazy[rt], mid-l); // (mid-l+1)-1 tree[rs] = seg(lazy[rt], lazy[rt], r-mid-1); // (r-mid)-1 lazy[rt] = 0; return ;}void upd(int rt, int l, int r, int L, int R, int col) { if (L&lt;=l &amp;&amp; r&lt;=R) { lazy[rt] = col; tree[rt] = seg(col, col, r-l); // (r-l+1)-1 return ; } pushdown(rt, l, r); int mid = (l+r) &gt;&gt; 1; if (L&lt;=mid) upd(ls, l, mid, L, R, col); if (R&gt;mid) upd(rs, mid+1, r, L, R, col); pushup(rt); return ;}seg query(int rt, int l, int r, int L, int R) { if (L&lt;=l &amp;&amp; r&lt;=R) return tree[rt]; pushdown(rt, l, r); int mid = (l+r) &gt;&gt; 1, tag = 0; seg ans1, ans2; if (L&lt;=mid) ans1 = query(ls, l, mid, L, R), ++tag; if (R&gt;mid) ans2 = query(rs, mid+1, r, L, R), tag += 2; if (tag == 1) return ans1; else if (tag == 2) return ans2; return Merge(ans1, ans2);}void addEdge(int u, int v) { e[++cnt].to = v; e[cnt].nxt = head[u]; head[u] = cnt; return ;}void dfs1(int cur, int f) { dep[cur] = dep[f] + 1; fa[cur] = f, siz[cur] = 1; int heavyson = -1; for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (to == f) continue; dfs1(to, cur), siz[cur] += siz[to]; if (siz[to] &gt; heavyson) heavyson = siz[to], son[cur] = to; } return ;}void dfs2(int cur, int Tp) { tp[cur] = Tp, id[cur] = ++idx; if (!son[cur]) return ; dfs2(son[cur], Tp); for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (to == son[cur] || to == fa[cur]) continue; dfs2(to, to); } return ;}void up(int l, int r, int col) { while (tp[l] ^ tp[r]) { if (dep[tp[l]] &lt; dep[tp[r]]) swap(l, r); upd(1, 1, n, id[tp[l]], id[l], col); l = fa[tp[l]]; } if (dep[l] &gt; dep[r]) swap(l, r); upd(1, 1, n, id[l], id[r], col); return ;}const seg NUL = seg(0, 0, 0);int qu(int l, int r) { int belong = 0; seg ans[2]; ans[0] = seg(0, 0, 0), ans[1] = ans[0]; while (tp[l] ^ tp[r]) { if (dep[tp[l]] &lt; dep[tp[r]]) { belong = 1 - belong; swap(l, r); } seg cur = query(1, 1, n, id[tp[l]], id[l]); if (belong) ans[1] = Merge(cur, ans[1]); else ans[0] = seg(ans[0].lc, cur.lc, ans[0].val+cur.val+(ans[0].rc==cur.rc)); l = fa[tp[l]]; } if (dep[l] &gt; dep[r]) { belong = 1 - belong; swap(l, r); } seg cur = query(1, 1, n, id[l], id[r]); if (!belong) ans[1] = Merge(cur, ans[1]); else ans[0] = seg(ans[0].lc, cur.lc, ans[0].val+cur.val+(ans[0].rc==cur.rc)); return Merge(ans[0], ans[1]).val;}void read(int &amp;ret) { ret = 0; char ch = getchar(); while (!isdigit(ch)) ch = getchar(); while (isdigit(ch)) { ret = (ret&lt;&lt;1) + (ret&lt;&lt;3) + (ch^48); ch = getchar(); } return ;}int main() { read(T); while (T--) { read(n), read(m); cnt = idx = 0; for (int i=1; i&lt;=n; ++i) { siz[i] = dep[i] = son[i] = 0; id[i] = tp[i] = fa[i] = head[i] = 0; tree[i*4-3] = tree[i*4-2] = tree[i*4-1] = tree[i*4] = NUL; lazy[i*4-3] = lazy[i*4-2] = lazy[i*4-1] = lazy[i*4] = 0; } for (int i=1; i&lt;n; ++i) { int u, v; read(u), read(v); addEdge(u, v), addEdge(v, u); } dfs1(1, 1), dfs2(1, 1); for (int i=1; i&lt;=n; ++i) upd(1, 1, n, id[i], id[i], -i); while (m--) { int opt, u, v; read(opt), read(u), read(v); if (opt == 1) up(u, v, m); else printf(&quot;%d\\n&quot;, qu(u, v)); } } return 0;} P2486 染色 什么时候 NOI 能出一些不重复的题目啊 …（指 NOI2021 D1T1）这个 trick 和上面一题几乎一致，但是这个时候初始贡献为 $1$。每一次 update 的区间贡献都为 $1$，判断 ls.rc=rs.lc 那么贡献 $-1$。 代码如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;int n, m, cnt, idx, lazy[N&lt;&lt;2];int head[N&lt;&lt;1], dep[N], siz[N];int tp[N], son[N], fa[N], id[N];int w[N], wl[N];struct Edge { int to, nxt; } e[N&lt;&lt;1];struct seg { int lc, rc, val; seg(int lc, int rc, int val): lc(lc), rc(rc), val(val) {} seg() {}} tree[N&lt;&lt;2];#define ls ((rt)&lt;&lt;1)#define rs ((rt)&lt;&lt;1|1)void pushup(int rt) { tree[rt].lc = tree[ls].lc; tree[rt].rc = tree[rs].rc; tree[rt].val = tree[ls].val + tree[rs].val; if (tree[ls].rc == tree[rs].lc) --tree[rt].val; return ;}seg Merge(seg L, seg R) { seg cur; cur.lc = L.lc, cur.rc = R.rc; cur.val = L.val + R.val; if (L.rc == R.lc) --cur.val; return cur;}void pushdown(int rt, int l, int r) { if (!lazy[rt]) return ; int mid = (l+r) &gt;&gt; 1; lazy[ls] = lazy[rs] = lazy[rt]; tree[ls] = seg(lazy[rt], lazy[rt], 1); tree[rs] = seg(lazy[rt], lazy[rt], 1); lazy[rt] = 0; return ;}void upd(int rt, int l, int r, int L, int R, int col) { if (L&lt;=l &amp;&amp; r&lt;=R) { lazy[rt] = col; tree[rt] = seg(col, col, 1); return ; } pushdown(rt, l, r); int mid = (l+r) &gt;&gt; 1; if (L&lt;=mid) upd(ls, l, mid, L, R, col); if (R&gt;mid) upd(rs, mid+1, r, L, R, col); pushup(rt); return ;}seg query(int rt, int l, int r, int L, int R) { if (L&lt;=l &amp;&amp; r&lt;=R) return tree[rt]; pushdown(rt, l, r); int mid = (l+r) &gt;&gt; 1, tag = 0; seg ans1, ans2; if (L&lt;=mid) ans1 = query(ls, l, mid, L, R), ++tag; if (R&gt;mid) ans2 = query(rs, mid+1, r, L, R), tag += 2; if (tag == 1) return ans1; if (tag == 2) return ans2; return Merge(ans1, ans2);}void addEdge(int u, int v) { e[++cnt].to = v; e[cnt].nxt = head[u]; head[u] = cnt; return ;}void dfs1(int cur, int f) { dep[cur] = dep[f] + 1; fa[cur] = f, siz[cur] = 1; int heavyson = -1; for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (to == f) continue; dfs1(to, cur), siz[cur] += siz[to]; if (siz[to] &gt; heavyson) heavyson = siz[to], son[cur] = to; } return ;}void dfs2(int cur, int Tp) { tp[cur] = Tp, id[cur] = ++idx, wl[idx] = w[cur]; if (!son[cur]) return ; dfs2(son[cur], Tp); for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (to == fa[cur] || to == son[cur]) continue; dfs2(to, to); } return ;}void up(int l, int r, int col) { while (tp[l] ^ tp[r]) { if (dep[tp[l]] &lt; dep[tp[r]]) swap(l, r); upd(1, 1, n, id[tp[l]], id[l], col); l = fa[tp[l]]; } if (dep[l] &gt; dep[r]) swap(l, r); upd(1, 1, n, id[l], id[r], col); return ;}const seg NUL = seg(0, 0, 0);int qu(int l, int r) { int belong = 0; seg ans[2]; ans[0] = ans[1] = NUL; while (tp[l] ^ tp[r]) { if (dep[tp[l]] &lt; dep[tp[r]]) { belong = 1 - belong; swap(l, r); } seg cur = query(1, 1, n, id[tp[l]], id[l]); if (belong) ans[1] = Merge(cur, ans[1]); else ans[0] = seg(ans[0].lc, cur.lc, ans[0].val+cur.val-(ans[0].rc==cur.rc)); l = fa[tp[l]]; } if (dep[l] &gt; dep[r]) { belong = 1 - belong; swap(l, r); } seg cur = query(1, 1, n, id[l], id[r]); if (!belong) ans[1] = Merge(cur, ans[1]); else ans[0] = seg(ans[0].lc, cur.lc, ans[0].val+cur.val-(ans[0].rc==cur.rc)); return Merge(ans[0], ans[1]).val;}void build(int rt, int l, int r) { if (l==r) { tree[rt].val = 1; tree[rt].lc = tree[rt].rc = wl[l]; return ; } int mid = (l+r) &gt;&gt; 1; build(ls, l, mid), build(rs, mid+1, r); pushup(rt); return ;}void read(int &amp;ret) { ret = 0; char ch = getchar(); while (!isdigit(ch)) ch = getchar(); while (isdigit(ch)) { ret = (ret&lt;&lt;1) + (ret&lt;&lt;3) + (ch^48); ch = getchar(); } return ;}int main() { read(n), read(m); for (int i=1; i&lt;=n; ++i) read(w[i]); for (int i=1; i&lt;n; ++i) { int u, v; read(u), read(v); addEdge(u, v), addEdge(v, u); } dfs1(1, 1), dfs2(1, 1); build(1, 1, n); while (m--) { char opt; cin &gt;&gt; opt; int u, v, color; read(u), read(v); if (opt == 'C') read(color), up(u, v, color); else printf(&quot;%d\\n&quot;, qu(u, v)); } return 0;}","link":"/2021/08/03/DS-On-Tree/"}],"tags":[{"name":"DS","slug":"DS","link":"/tags/DS/"},{"name":"Number Theory","slug":"Number-Theory","link":"/tags/Number-Theory/"},{"name":"Others","slug":"Others","link":"/tags/Others/"},{"name":"Graph","slug":"Graph","link":"/tags/Graph/"},{"name":"State Compression","slug":"State-Compression","link":"/tags/State-Compression/"},{"name":"Network Flows","slug":"Network-Flows","link":"/tags/Network-Flows/"}],"categories":[{"name":"Notes","slug":"Notes","link":"/categories/Notes/"},{"name":"Sol","slug":"Sol","link":"/categories/Sol/"},{"name":"Daily","slug":"Daily","link":"/categories/Daily/"}]}