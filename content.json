{"pages":[],"posts":[{"title":"DS On Tree","text":"P3384 轻重链剖分 显然的板子题。 那么我们只需要干这样一件事情，就是按照重儿子的顺序来进行 DFS，那么这样我们就可以通过 DFS 序这样一个东西来进行子树的查询和更改，同时也可以通过跳链顶，类似 LCA 的操作，来进行路径的修改和查询。这都非常容易实现。 同时有几个我容易犯错的地方。 树剖几大毒瘤问题 if(dep[tp[l]] &lt; dep[tp[r]]) swap(l, r);这个很显然，因为树剖是按照 tp-&gt;node 的顺序所以是 tp 来 swap。 upd(1, 1, n, id[tp[l]], id[l], f);我也不知道我为什么 id[l] 能够写成 tp[l]。 搞线段树的时候要注意 pushdown 的灵活变通，不要把修改值弄成了加法和乘法。 所以代码会长下面这样。顺带一提，这是我重写了几万遍之后确定的样式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 1e5 + 10;int n, m, root, Mod, cnt, idx;int w[N], wl[N], val[N&lt;&lt;2], head[N&lt;&lt;1];int dep[N], id[N], fa[N], son[N];int lazy[N&lt;&lt;2], tp[N], siz[N];struct Edge { int to, nxt;} e[N&lt;&lt;1];void addEdge(int u, int v) { e[++cnt].to = v; e[cnt].nxt = head[u]; head[u] = cnt; return ;}#define ls ((rt)&lt;&lt;1)#define rs ((rt)&lt;&lt;1|1)void read(int &amp;ret) { ret = 0; char ch = getchar(); while (!isdigit(ch)) ch = getchar(); while (isdigit(ch)) { ret = (ret&lt;&lt;1) + (ret&lt;&lt;3) + (ch^48); ch = getchar(); } return ;}void pushup(int rt) { val[rt] = (val[ls] + val[rs]) % Mod; return ;}void build(int rt, int l, int r) { if (l==r) { val[rt] = wl[l]; return ; } int mid = (l+r) &gt;&gt; 1; build(ls, l, mid); build(rs, mid+1, r); pushup(rt); return ;}void pushdown(int rt, int l, int r) { if (!lazy[rt]) return ; int mid = (l+r) &gt;&gt; 1; lazy[ls] += lazy[rt], lazy[rs] += lazy[rt]; lazy[ls] %= Mod, lazy[rs] %= Mod; val[ls] = (val[ls] + (mid-l+1) * lazy[rt]) % Mod; val[rs] = (val[rs] + (r-mid) * lazy[rt]) % Mod; lazy[rt] = 0; return ;}void upd(int rt, int l, int r, int L, int R, int f) { if (L&lt;=l &amp;&amp; r&lt;=R) { val[rt] += (r-l+1) * f, val[rt] %= Mod; lazy[rt] += f, lazy[rt] %= Mod; return ; } pushdown(rt, l, r); int mid = (l+r) &gt;&gt; 1; if (L&lt;=mid) upd(ls, l, mid, L, R, f); if (R&gt;mid) upd(rs, mid+1, r, L, R, f); pushup(rt); return ;}int query(int rt, int l, int r, int L, int R) { if (L&lt;=l &amp;&amp; r&lt;=R) return val[rt]; pushdown(rt, l, r); int mid = (l+r) &gt;&gt; 1, ans = 0; if (L&lt;=mid) ans += query(ls, l, mid, L, R); if (R&gt;mid) ans += query(rs, mid+1, r, L, R); return ans % Mod;}void dfs1(int cur, int f) { dep[cur] = dep[f] + 1; siz[cur] = 1, fa[cur] = f; int heavyson = -1; for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (to==f) continue; dfs1(to, cur), siz[cur] += siz[to]; if (siz[to]&gt;heavyson) heavyson = siz[to], son[cur] = to; } return ;}void dfs2(int cur, int Tp) { id[cur] = ++idx, wl[idx] = w[cur]; tp[cur] = Tp; if (!son[cur]) return ; dfs2(son[cur], Tp); for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (to==son[cur] || to==fa[cur]) continue; dfs2(to, to); } return ;}void up(int l, int r, int f) { f %= Mod; while (tp[l] ^ tp[r]) { if (dep[tp[l]] &lt; dep[tp[r]]) swap(l, r); upd(1, 1, n, id[tp[l]], id[l], f); l = fa[tp[l]]; } if (dep[l] &gt; dep[r]) swap(l, r); upd(1, 1, n, id[l], id[r], f); return ;}int qu(int l, int r) { int ans = 0; while (tp[l] ^ tp[r]) { if (dep[tp[l]] &lt; dep[tp[r]]) swap(l, r); ans = (ans + query(1, 1, n, id[tp[l]], id[l])) % Mod; l = fa[tp[l]]; } if (dep[l] &gt; dep[r]) swap(l, r); ans = (ans + query(1, 1, n, id[l], id[r])) % Mod; return ans;}void upsub(int x, int f) { upd(1, 1, n, id[x], id[x]+siz[x]-1, f); }int qusub(int x) { return query(1, 1, n, id[x], id[x]+siz[x]-1); }signed main() { read(n), read(m); read(root), read(Mod); for (int i=1; i&lt;=n; ++i) read(w[i]); for (int i=1; i&lt;n; ++i) { int u, v; read(u), read(v); addEdge(u, v); addEdge(v, u); } dfs1(root, root); dfs2(root, 0); build(1, 1, n); while (m--) { int opt, x, y, z; read(opt); if (opt==1) { read(x), read(y), read(z); up(x, y, z); } else if (opt==2) { read(x), read(y); printf(&quot;%lld\\n&quot;, qu(x, y) % Mod); } else if (opt==3) { read(x), read(z); upsub(x, z); } else { read(x); printf(&quot;%lld\\n&quot;, qusub(x) % Mod); } } return 0;} P2590 树的统计 更简单了，甚至不需要 lazytag。 代码如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;stdio.h&gt;#include &lt;iostream&gt;#define isdigit(ch) (ch&gt;47&amp;&amp;ch&lt;58)void read(int &amp;ret) { ret = 0; char ch = getchar(); int f = 1; while (!isdigit(ch) &amp;&amp; ch ^ '-') ch = getchar(); if (ch == '-') f = -1, ch = getchar(); while (isdigit(ch)) { ret = (ret&lt;&lt;1) + (ret&lt;&lt;3) + (ch^48); ch = getchar(); } ret *= f; return ;}void out(int ret) { if (ret&lt;0) { ret = -ret, putchar('-'); } if (ret&gt;9) out(ret/10); putchar(ret%10 ^ 48); return ;}const int N = 3e4 + 10;int n, Q, cnt, dfn;int w[N], v[N], head[N];int val[N&lt;&lt;2], siz[N], Maxi[N&lt;&lt;2];int id[N], fa[N], tp[N], son[N], dep[N];char str[10];int max(int x, int y) { return x&gt;y? x:y; }void swap(int &amp;x, int &amp;y) { x ^= y ^= x ^= y; }struct Edge { int to, nxt;} e[N&lt;&lt;1];#define ls ((rt)&lt;&lt;1)#define rs ((rt)&lt;&lt;1|1)void addEdge(int u, int v) { e[++cnt].to = v; e[cnt].nxt = head[u]; head[u] = cnt; return ;}void pushup(int rt) { val[rt] = val[ls] + val[rs]; Maxi[rt] = max(Maxi[ls], Maxi[rs]); return ;}void build(int rt, int l, int r) { if (l == r) { val[rt] = Maxi[rt] = v[l]; return ; } int mid = (l+r) &gt;&gt; 1; build(ls, l, mid); build(rs, mid+1, r); pushup(rt); return ;}void upd(int rt, int l, int r, int pos, int f) { if (l == r) { val[rt] = Maxi[rt] = f; return ; } int mid = (l+r) &gt;&gt; 1; if (pos&lt;=mid) upd(ls, l, mid, pos, f); if (pos&gt;mid) upd(rs, mid+1, r, pos, f); pushup(rt); return ;}int querys(int rt, int l, int r, int L, int R) { if (L&lt;=l &amp;&amp; r&lt;=R) return val[rt]; int mid = (l+r) &gt;&gt; 1, ans = 0; if (L&lt;=mid) ans += querys(ls, l, mid, L, R); if (R&gt;mid) ans += querys(rs, mid+1, r, L, R); return ans;}int querym(int rt, int l, int r, int L, int R) { if (L&lt;=l &amp;&amp; r&lt;=R) return Maxi[rt]; int mid = (l+r) &gt;&gt; 1, Max = -1e9; if (L&lt;=mid) Max = max(Max, querym(ls, l, mid, L, R)); if (R&gt;mid) Max = max(Max, querym(rs, mid+1, r, L, R)); return Max;}void dfs1(int cur, int Fa) { dep[cur] = dep[Fa] + 1; fa[cur] = Fa, siz[cur] = 1; int heavyson = -1; for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (to == Fa) continue; dfs1(to, cur); siz[cur] += siz[to]; if (siz[to] &gt; heavyson) son[cur] = to, heavyson = siz[to]; } return ;}void dfs2(int cur, int Tp) { id[cur] = ++dfn; v[dfn] = w[cur], tp[cur] = Tp; if (!son[cur]) return ; dfs2(son[cur], Tp); for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (to == fa[cur] || to == son[cur]) continue; dfs2(to, to); } return ;}int qus(int l, int r) { int ans = 0; while (tp[l] ^ tp[r]) { if (dep[tp[l]] &lt; dep[tp[r]]) swap(l, r); int cur = querys(1, 1, n, id[tp[l]], id[l]); ans += cur, l = fa[tp[l]]; } if (dep[l] &gt; dep[r]) swap(l, r); ans += querys(1, 1, n, id[l], id[r]); return ans;}int qum(int l, int r) { int ans = -1e9; while (tp[l] ^ tp[r]) { if (dep[tp[l]] &lt; dep[tp[r]]) swap(l, r); int cur = querym(1, 1, n, id[tp[l]], id[l]); ans = max(ans, cur), l = fa[tp[l]]; } if (dep[l] &gt; dep[r]) swap(l, r); ans = max(ans, querym(1, 1, n, id[l], id[r])); return ans;}int main() {// freopen(&quot;P2590.in&quot;, &quot;r&quot;, stdin);// freopen(&quot;P2590.out&quot;, &quot;w&quot;, stdout); read(n); for (int i=1; i&lt;n; ++i) { int x, y; read(x), read(y); addEdge(x, y), addEdge(y, x); } for (int i=1; i&lt;=n; ++i) read(w[i]); dfs1(1, 1), dfs2(1, 1); build(1, 1, n); read(Q); while (Q--) { std::cin &gt;&gt; str+1; int l, r; read(l), read(r); if (str[1] == 'C') upd(1, 1, n, id[l], r); else if (str[2] == 'M') out(qum(l, r)), puts(&quot;&quot;); else if (str[2] == 'S') out(qus(l, r)), puts(&quot;&quot;); } return 0;} P2146 软件包管理器 简单 trick。 只需要将依赖关系转化为树上关系就可以了。然后就是要区分 0 和 unedited，完全不一样。所以可以直接将 unedited 设置为 -1 然后乱搞即可。 注意是赋值而不是加法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;bits/stdc++.h&gt;using namespace std;void read(int &amp;ret) { ret = 0; char ch = getchar(); while (!isdigit(ch)) ch = getchar(); while (isdigit(ch)) { ret = (ret&lt;&lt;1) + (ret&lt;&lt;3) + (ch^48); ch = getchar(); } return ;}const int N = 1e5 + 10;int n, Q, cnt, idx, head[N];int val[N&lt;&lt;2], lazy[N&lt;&lt;2];int id[N], tp[N], siz[N], dep[N];char opt[20]; int fa[N], son[N];struct Edge { int to, nxt; } e[N];void addEdge(int u, int v) { e[++cnt].to = v; e[cnt].nxt = head[u]; head[u] = cnt; return ;}#define ls ((rt)&lt;&lt;1)#define rs ((rt)&lt;&lt;1|1)void pushup(int rt) { val[rt] = val[ls] + val[rs]; return ;}void pushdown(int rt, int l, int r) { if (lazy[rt]&lt;0) return ; int mid = (l+r) &gt;&gt; 1; lazy[ls] = lazy[rt], lazy[rs] = lazy[rt]; val[ls] = lazy[rt] * (mid-l+1); val[rs] = lazy[rt] * (r-mid); lazy[rt] = -1; return ;}void upd(int rt, int l, int r, int L, int R, int f) { if (L&lt;=l &amp;&amp; r&lt;=R) { lazy[rt] = f; val[rt] = f * (r-l+1); return ; } pushdown(rt, l, r); int mid = (l+r) &gt;&gt; 1; if (L&lt;=mid) upd(ls, l, mid, L, R, f); if (R&gt;mid) upd(rs, mid+1, r, L, R, f); pushup(rt); return ;}int query(int rt, int l, int r, int L, int R) { if (L&lt;=l &amp;&amp; r&lt;=R) return val[rt]; pushdown(rt, l, r); int mid = (l+r) &gt;&gt; 1, ans = 0; if (L&lt;=mid) ans += query(ls, l, mid, L, R); if (R&gt;mid) ans += query(rs, mid+1, r, L, R); return ans;}void dfs1(int cur, int f) { dep[cur] = dep[f] + 1; fa[cur] = f, siz[cur] = 1; int heavyson = -1; for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; dfs1(to, cur), siz[cur] += siz[to]; if (siz[to] &gt; heavyson) heavyson = siz[to], son[cur] = to; } return ;}void dfs2(int cur, int Tp) { id[cur] = ++idx; tp[cur] = Tp; if (!son[cur]) return ; dfs2(son[cur], Tp); for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (to==son[cur]) continue; dfs2(to, to); } return ;}void up(int l, int r, int f) { while (tp[l] ^ tp[r]) { if (dep[tp[l]] &lt; dep[tp[r]]) swap(l, r); upd(1, 1, n, id[tp[l]], id[l], f); l = fa[tp[l]]; } if (dep[l] &gt; dep[r]) swap(l, r); upd(1, 1, n, id[l], id[r], f); return ;}int main() {// freopen(&quot;P2146.in&quot;, &quot;r&quot;, stdin); memset(lazy, -1, sizeof lazy); read(n); for (int i=2; i&lt;=n; ++i) { int v; read(v); addEdge(v+1, i); } dfs1(1, 1), dfs2(1, 1), read(Q); while (Q--) { cin &gt;&gt; opt+1; int v; read(v); ++v; int cur = query(1, 1, n, 1, n); if (opt[1]=='i') up(1, v, 1); else if (opt[1]=='u') upd(1, 1, n, id[v], id[v]+siz[v]-1, 0); int to = query(1, 1, n, 1, n); printf(&quot;%d\\n&quot;, abs(cur-to)); } return 0;} P3178 树上操作 也是个简单题，就是不要被 from 和 to 骗了，双向边肯定要连的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;void read(int &amp;ret) { ret = 0; char ch = getchar(); int f = 1; while (!isdigit(ch) &amp;&amp; ch^'-') ch = getchar(); if (ch=='-') f = -1, ch = getchar(); while (isdigit(ch)) { ret = (ret&lt;&lt;1) + (ret&lt;&lt;3) + (ch^48); ch = getchar(); } ret *= f; return ;}const int N = 1e5 + 10;int n, m, cnt, idx;int dep[N], son[N], fa[N], siz[N];int head[N&lt;&lt;1], tp[N], w[N], wl[N], id[N];struct Edge { int to, nxt; } e[N&lt;&lt;1];void addEdge(int u, int v) { e[++cnt].to = v; e[cnt].nxt = head[u]; head[u] = cnt; return ;}int lazy[N&lt;&lt;2], val[N&lt;&lt;2];#define ls ((rt)&lt;&lt;1)#define rs ((rt)&lt;&lt;1|1)void pushup(int rt) { val[rt] = val[ls] + val[rs]; return ;}void build(int rt, int l, int r) { if (l==r) { val[rt] = wl[l]; return ; } int mid = (l+r) &gt;&gt; 1; build(ls, l, mid); build(rs, mid+1, r); pushup(rt); return ;}void pushdown(int rt, int l, int r) { if (!lazy[rt]) return ; int mid = (l+r) &gt;&gt; 1; lazy[ls] += lazy[rt], lazy[rs] += lazy[rt]; val[ls] += (mid-l+1) * lazy[rt]; val[rs] += (r-mid) * lazy[rt]; lazy[rt] = 0; return ;}void upd(int rt, int l, int r, int L, int R, int f) { if (L&lt;=l &amp;&amp; r&lt;=R) { lazy[rt] += f; val[rt] += f * (r-l+1); return ; } int mid = (l+r) &gt;&gt; 1; pushdown(rt, l, r); if (L&lt;=mid) upd(ls, l, mid, L, R, f); if (R&gt;mid) upd(rs, mid+1, r, L, R, f); pushup(rt); return ;}int query(int rt, int l, int r, int L, int R) { if (L&lt;=l &amp;&amp; r&lt;=R) return val[rt]; int ans = 0, mid = (l+r) &gt;&gt; 1; pushdown(rt, l, r); if (L&lt;=mid) ans += query(ls, l, mid, L, R); if (R&gt;mid) ans += query(rs, mid+1, r, L, R); return ans;}void dfs1(int cur, int f) { fa[cur] = f, siz[cur] = 1; dep[cur] = dep[f] + 1; int heavyson = -1; for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (to==f) continue; dfs1(to, cur); siz[cur] += siz[to]; if (siz[to] &gt; heavyson) heavyson = siz[to], son[cur] = to; } return ;}void dfs2(int cur, int Tp) { id[cur] = ++idx, wl[idx] = w[cur]; tp[cur] = Tp; if (!son[cur]) return ; dfs2(son[cur], Tp); for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (to==fa[cur] || to==son[cur]) continue; dfs2(to, to); } return ;}int que(int l, int r) { int ans = 0; while (tp[l] ^ tp[r]) { if (dep[tp[l]] &lt; dep[tp[r]]) swap(l, r); ans += query(1, 1, n, id[tp[l]], id[l]); l = fa[tp[l]]; } if (dep[l] &gt; dep[r]) swap(l, r); ans += query(1, 1, n, id[l], id[r]); return ans;}signed main() { read(n), read(m); for (int i=1; i&lt;=n; ++i) read(w[i]); for (int i=1; i&lt;n; ++i) { int u, v; read(u), read(v); addEdge(u, v); addEdge(v, u); } dfs1(1, 1), dfs2(1, 1); build(1, 1, n); while (m--) { int opt, x, a; read(opt), read(x); if (opt==1) { read(a); upd(1, 1, n, id[x], id[x], a); } else if (opt==2) { read(a); upd(1, 1, n, id[x], id[x]+siz[x]-1, a); } else printf(&quot;%lld\\n&quot;, que(1, x)); } return 0;}","link":"/2021/08/03/DS-On-Tree/"},{"title":"Introduction","text":"First of all, this is my first successful hexo Blog!I may be a pigeon in the future … u1s1 hexo is better than Gridea …And maybe I will put my Luogu Blog away qaq Test for Markdown &amp; LaTeX$$\\sum\\limits_{i=1}^na_i$$","link":"/2021/08/02/Introduction/"},{"title":"Kill Network-Flows","text":"P2756 飞行员配对方案问题 只要默认前面 $m$ 个都是外国的，然后剩下的都是英国的，接着暴力建图跑 Dinic 即可。貌似只需要弄一个源点 $0$ 和汇点 $n+1$ 即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;const int N = 2e4 + 10;int n, m, cnt = 1;int head[N], dep[N];bool vis[N];struct Edge { int to, nxt, val;} e[N];void addEdge(int u, int v, int w) { e[++cnt].to = v; e[cnt].nxt = head[u]; e[cnt].val = w; head[u] = cnt; return ;}bool check() { for (int i=0; i&lt;=n+1; ++i) dep[i] = 0; dep[0] = 2; queue &lt;int&gt; sp; sp.push(0); while (!sp.empty()) { int cur = sp.front(); sp.pop(); for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (!dep[to] &amp;&amp; e[i].val) { dep[to] = dep[cur] + 1, sp.push(to); if (to==n+1) return true; } } } return false;}int dfs(int cur, int Max) { if (cur==n+1) return Max; int increase = Max; for (int i=head[cur]; i&amp;&amp;increase; i=e[i].nxt) { int to = e[i].to; if (e[i].val &amp;&amp; dep[to]==dep[cur]+1) { int res = dfs(to, min(increase, e[i].val)); e[i].val -= res, e[i^1].val += res; if (!res) dep[to] = 0; increase -= res; } } return Max-increase;}void read(int &amp;ret) { ret = 0; char ch = getchar(); int f = 1; while (!isdigit(ch) &amp;&amp; ch^'-') ch = getchar(); if (ch=='-') f = -1, ch = getchar(); while (isdigit(ch)) { ret = (ret&lt;&lt;1) + (ret&lt;&lt;3) + (ch^48); ch = getchar(); } ret *= f; return ;}int main() { read(m), read(n); while (1) { int u, v; read(u), read(v); if (u==-1 &amp;&amp; v==-1) break; addEdge(u, v, inf); addEdge(v, u, 0); } for (int i=1; i&lt;=m; ++i) addEdge(0, i, 1), addEdge(i, 0, 0); for (int i=m+1; i&lt;=n; ++i) addEdge(i, n+1, 1), addEdge(n+1, i, 0); int ans = 0; while(check()) ans += dfs(0, inf); cout &lt;&lt; ans &lt;&lt; endl; for (int i=2; i&lt;=cnt; i+=2) { if (!e[i^1].val) continue; if (!e[i].to || !e[i^1].to) continue; if (e[i].to==n+1) continue; if (e[i^1].to==n+1) continue; printf(&quot;%d %d\\n&quot;, e[i^1].to, e[i].to); } return 0;} P1251 餐巾计划问题 这道题最重要的是连边。那么很显然的拆点技巧，将一天拆成服务和收工两个点，即 i+N 和 i，后前两个点。那么源点为 0，汇点为 2*N+1。 要购买餐巾 显然从源点处购买，直接建边 add(0,i+N,inf,p)。 偷懒先不洗餐巾 显然直接延到下一天，add(i,i+1,inf,0)。 快洗 显然直接丢到 $m$ 天后，add(i,i+N+m,inf,f)。 慢洗 同理丢到 $n$ 天后，add(i,i+N+n,inf,s)。 然后每一天要跑至少为 r[i] 的流量，直接源点连收工，汇点连服务。 然后跑一遍最小费用最大流即可。 nt 的地方：DFS 要标记 cur，数组不要开小。要是写对了正解然后数组开小了那就真的是个 zz。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int MAXN = 2e3 + 10;const int inf = 2e9;int N, cnt = 1, head[MAXN*12];int p, m, f, n, s, dist[MAXN*12];bool inq[MAXN*2], vis[MAXN*2];int cost;struct Edge { int to, nxt, flow, val;} e[MAXN*12];void addEdge(int u, int v, int f, int w) { e[++cnt].to = v; e[cnt].nxt = head[u]; e[cnt].flow = f, e[cnt].val = w; head[u] = cnt; e[++cnt].to = u; e[cnt].nxt = head[v]; e[cnt].flow = 0, e[cnt].val = -w; head[v] = cnt; return ;}void read(int &amp;ret) { ret = 0; char ch = getchar(); while (!isdigit(ch)) ch = getchar(); while (isdigit(ch)) { ret = (ret&lt;&lt;1) + (ret&lt;&lt;3) + (ch^48); ch = getchar(); } return ;}bool spfa() { for (int i=0; i&lt;=2*N+1; ++i) dist[i] = inf, inq[i] = false; dist[0] = 0, inq[0] = true; queue &lt;int&gt; sp; sp.push(0); while (!sp.empty()) { int cur = sp.front(); sp.pop(); inq[cur] = false; for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (e[i].flow &amp;&amp; dist[to]&gt;dist[cur]+e[i].val) { dist[to] = dist[cur] + e[i].val; if (!inq[to]) inq[to] = true, sp.push(to); } } } return dist[2*N+1] &lt; inf;}int dfs(int cur, int Max) { if (cur == 2*N+1) { vis[cur] = true; return Max; } int increase = Max; vis[cur] = true; for (int i=head[cur]; i &amp;&amp; increase; i=e[i].nxt) { int to = e[i].to; if ((!vis[to] || to==MAXN) &amp;&amp; e[i].flow &amp;&amp; dist[to]==dist[cur]+e[i].val) { int res = dfs(to, min(increase, e[i].flow)); if (!res) continue; e[i].flow -= res, e[i^1].flow += res; cost += res * e[i].val, increase -= res; } } return Max-increase;}signed main() { cin &gt;&gt; N; for (int i=1; i&lt;=N; ++i) { int r; cin &gt;&gt; r; addEdge(0, i, r, 0); addEdge(i+N, 2*N+1, r, 0); } cin &gt;&gt; p &gt;&gt; m &gt;&gt; f &gt;&gt; n &gt;&gt; s; // begin point: i // ending point: i+N for (int i=1; i&lt;=N; ++i) { addEdge(0, i+N, inf, p); if (i&lt;N) addEdge(i, i+1, inf, 0); if (i+m&lt;=N) addEdge(i, i+N+m, inf, f); if (i+n&lt;=N) addEdge(i, i+N+n, inf, s); } while (spfa()) { for (int i=0; i&lt;=2*N+1; ++i) vis[i] = false; dfs(0, inf); } cout &lt;&lt; cost &lt;&lt; endl; return 0;} P4011 孤岛营救问题 这道题为什么要网络流啊。 难道不是直接暴力 BFS 寻找路径吗？ 直接状压一下钥匙，然后每一次到达门就看有没有钥匙就可以了。 nt 的地方：x(x), y(y) 写成了 x(x), y(x) … … 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 11;const int dx[] = {0, 1, 0, -1};const int dy[] = {1, 0, -1, 0};int n, m, p, k, s, door[N][N][N][N];int cnt[N][N], key[N][N][N];bool vis[N][N][1&lt;&lt;N];struct spread { int x, y, Key, cost; spread(int x, int y, int Key, int cost): x(x), y(y), Key(Key), cost(cost) {} spread() {}};int keyset(int x, int y) { int S = 0; for (int i=1; i&lt;=cnt[x][y]; ++i) S |= (1&lt;&lt;(key[x][y][i]-1)); return S;}bool check(int x, int y, int k, int st) { if (x&lt;1 || x&gt;n) return false; if (y&lt;1 || y&gt;m) return false; if (k&lt;0 || (k &amp;&amp; !(st&amp;(1&lt;&lt;(k-1))))) return false; return true;}int bfs() { int x = 1, y = 1; int S = keyset(x, y); queue &lt;spread&gt; que; que.push(spread(x, y, S, 0)); vis[x][y][S] = true; while (!que.empty()) { spread cur = que.front(); que.pop(); x = cur.x, y = cur.y, S = cur.Key; if (x==n &amp;&amp; y==m) return cur.cost; for (int i=0; i&lt;4; ++i) { int tox = x + dx[i], toy = y + dy[i]; int Door = door[x][y][tox][toy]; if (!check(tox, toy, Door, S)) continue; int to = S|keyset(tox, toy); if (vis[tox][toy][to]) continue; vis[tox][toy][to] = true; que.push(spread(tox, toy, to, cur.cost+1)); } } return -1;}int main() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; p &gt;&gt; k; while (k--) { int x, y, X, Y, G; cin &gt;&gt; x &gt;&gt; y &gt;&gt; X &gt;&gt; Y &gt;&gt; G; if (G) door[x][y][X][Y] = door[X][Y][x][y] = G; else door[x][y][X][Y] = door[X][Y][x][y] = -1; } cin &gt;&gt; s; while (s--) { int x, y, Q; cin &gt;&gt; x &gt;&gt; y &gt;&gt; Q; key[x][y][++cnt[x][y]] = Q; } cout &lt;&lt; bfs() &lt;&lt; endl; return 0;} P2764 最小路径覆盖问题 众所周知最小路径覆盖 $=$ 顶点数 $-$ 最大匹配数，这个是很显然的。 Proof：因为对于每一个点一开始都可以作为一条路径，所以一开始就有 $n$ 条路径。因为每一次匹配相当于把两个点合并，所以路径条数相当于减掉了 $1$，所以最大匹配数就是合并的个数，所以最后就是 $n-$最大匹配数。又因为二分图可以网络流乱搞，所以路径覆盖也可以网络流乱搞。 所以正常的 trick，拆点跑最大流。路径输出比较正常，直接在 DFS 的时候找到起始点然后记录路径即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;void read(int &amp;ret) { ret = 0; char ch = getchar(); while (!isdigit(ch)) ch = getchar(); while (isdigit(ch)) { ret = (ret&lt;&lt;1) + (ret&lt;&lt;3) + (ch^48); ch = getchar(); } return ;}const int N = 1e5 + 10;const int inf = 1e9;int n, m, s, t, cnt = 1;int dep[N], head[N]; bool inq[N];int cost, path[N]; bool vis[N];struct Edge { int to, nxt, flow;} e[N];void addEdge(int u, int v, int f) { e[++cnt].to = v; e[cnt].nxt = head[u]; e[cnt].flow = f; head[u] = cnt; e[++cnt].to = u; e[cnt].nxt = head[v]; e[cnt].flow = 0; head[v] = cnt; return ;}bool check() { for (int i=0; i&lt;=t; ++i) dep[i] = inf, inq[i] = false; dep[s] = 0; queue &lt;int&gt; sp; sp.push(s); inq[s] = true; while (!sp.empty()) { int cur = sp.front(); sp.pop(); for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (e[i].flow &amp;&amp; dep[to]==inf) { dep[to] = dep[cur] + 1, sp.push(to); } } } return dep[t] ^ inf;}int dfs(int cur, int Max) { if (cur==t) return Max; int increase = Max; for (int i=head[cur]; i &amp;&amp; increase; i=e[i].nxt) { int to = e[i].to; if (e[i].flow &amp;&amp; dep[to]==dep[cur]+1) { int res = dfs(to, min(increase, e[i].flow)); if (!res) { dep[to] = -1; continue; } e[i].flow -= res, e[i^1].flow += res; path[cur] = to; if (cur) vis[to-n] = true; increase -= res; } } return Max-increase;}int main() { cin &gt;&gt; n &gt;&gt; m; t = 2*n+1; for (int i=1; i&lt;=m; ++i) { int u, v; cin &gt;&gt; u &gt;&gt; v; addEdge(u, n+v, 1); } for (int i=1; i&lt;=n; ++i) addEdge(s, i, 1); for (int i=1; i&lt;=n; ++i) addEdge(i+n, t, 1); int ans = 0; while (check()) ans += dfs(s, inf); for (int i=1; i&lt;=n; ++i) { if (vis[i]) continue; int cur = i; cout &lt;&lt; i; while(path[cur] &amp;&amp; path[cur]^t) cout &lt;&lt; ' ' &lt;&lt; path[cur]-n, cur = path[cur]-n; cout &lt;&lt; endl; } cout &lt;&lt; n-ans &lt;&lt; endl; return 0;} P4016 负载平衡问题 听名字还挺高大上的。 其实就是个卡牌游戏啊，只不过每一次只可以交换环上相邻两个。那么直接断环成链，拿原数减掉最后的固定答案然后前缀和加到 ans。 顺带卡了下常，12ms 最优解 Rank1。 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;int n, sum, ans, a[110], Sum[110];int abs(int x) { return x&gt;0? x:-x; }void qsort(int l, int r) { int mid = Sum[(l+r)&gt;&gt;1]; int i=l, j=r; do { while (Sum[i]&lt;mid) ++i; while (Sum[j]&gt;mid) --j; if(i&lt;=j) { int u=Sum[i]; Sum[i]=Sum[j]; Sum[j]=u; i++, j--; } } while (i&lt;=j); if (l&lt;j) qsort(l, j); if (i&lt;r) qsort(i, r); return ;}int main() { scanf(&quot;%d&quot;, &amp;n); for (int i=1; i&lt;=n; ++i) scanf(&quot;%d&quot;, &amp;a[i]), sum += a[i]; sum /= n; for (int i=1; i&lt;=n; ++i) Sum[i] = Sum[i-1]+a[i]-sum, a[i] = Sum[i]; qsort(1, n); int mid = n/2+1; for (int i=1; i&lt;=n; ++i) ans += abs(Sum[mid]-Sum[i]); printf(&quot;%d\\n&quot;, ans); return 0;}","link":"/2021/08/02/Kill-Network-Flows/"},{"title":"差分约束重提","text":"P5960 差分约束算法 显然题。 首先有 $x_{c1}-x_{c1’} \\le y_1$。那么有 $x_{c1} \\le x_{c1’} + y_1$。所以看到图论里面的松弛操作，即最终使得 dist[to]&lt;=dist[cur]+e[i].val。 要使得这个成立所以要跑一遍最短路。 那么将 $x$ 视为 dist，c1 视为 to，c1' 视为 cur 即可。 然后因为跑最短路的 dijkstra 需要源点，即单源最短路径。所以直接造一个源点就可以跑了，并没有什么实际作用（ 判负环似乎只需要加上一个统计入队次数的 cnt 即可。因为显然，有负环就没有合法解。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e3 + 10;int n, m, cnt; bool inq[N];int head[N&lt;&lt;1], dist[N], vis[N];struct Edge { int to, nxt, val;} e[N&lt;&lt;1];void addEdge(int u, int v, int w) { e[++cnt].to = v; e[cnt].nxt = head[u]; e[cnt].val = w; head[u] = cnt; return ;}bool spfa() { queue &lt;int&gt; sp; sp.push(0); vis[0] = 1, inq[0] = true; memset(dist, 0x3f, sizeof dist); dist[0] = 0; while (!sp.empty()) { int cur = sp.front(); sp.pop(); inq[cur] = false; for (int i=head[cur]; ~i; i=e[i].nxt) { int to = e[i].to; if (dist[to] &gt; dist[cur]+e[i].val) { dist[to] = dist[cur] + e[i].val; if (!inq[to]) { inq[to] = true, sp.push(to); ++vis[to]; if (vis[to]&gt;n) return true; } } } } return false;}int main() { memset(head, -1, sizeof head); cin &gt;&gt; n &gt;&gt; m; for (int i=1; i&lt;=m; ++i) { int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; addEdge(v, u, w); } for (int i=1; i&lt;=n; ++i) addEdge(0, i, 0); if (spfa()) { puts(&quot;NO&quot;); return 0; } for (int i=1; i&lt;=n; ++i) cout &lt;&lt; dist[i] &lt;&lt; ' '; return 0;}","link":"/2021/08/03/System-of-Difference-Constraints/"}],"tags":[{"name":"DS","slug":"DS","link":"/tags/DS/"},{"name":"Others","slug":"Others","link":"/tags/Others/"},{"name":"Network Flows","slug":"Network-Flows","link":"/tags/Network-Flows/"},{"name":"Graph","slug":"Graph","link":"/tags/Graph/"}],"categories":[{"name":"Notes","slug":"Notes","link":"/categories/Notes/"},{"name":"Daily","slug":"Daily","link":"/categories/Daily/"}]}