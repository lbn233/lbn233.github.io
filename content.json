{"pages":[],"posts":[{"title":"DS On Tree","text":"P3384 轻重链剖分 显然的板子题。 那么我们只需要干这样一件事情，就是按照重儿子的顺序来进行 DFS，那么这样我们就可以通过 DFS 序这样一个东西来进行子树的查询和更改，同时也可以通过跳链顶，类似 LCA 的操作，来进行路径的修改和查询。这都非常容易实现。 同时有几个我容易犯错的地方。 树剖几大毒瘤问题 if(dep[tp[l]] &lt; dep[tp[r]]) swap(l, r);这个很显然，因为树剖是按照 tp-&gt;node 的顺序所以是 tp 来 swap。 upd(1, 1, n, id[tp[l]], id[l], f);我也不知道我为什么 id[l] 能够写成 tp[l]。 搞线段树的时候要注意 pushdown 的灵活变通，不要把修改值弄成了加法和乘法。 所以代码会长下面这样。顺带一提，这是我重写了几万遍之后确定的样式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 1e5 + 10;int n, m, root, Mod, cnt, idx;int w[N], wl[N], val[N&lt;&lt;2], head[N&lt;&lt;1];int dep[N], id[N], fa[N], son[N];int lazy[N&lt;&lt;2], tp[N], siz[N];struct Edge { int to, nxt;} e[N&lt;&lt;1];void addEdge(int u, int v) { e[++cnt].to = v; e[cnt].nxt = head[u]; head[u] = cnt; return ;}#define ls ((rt)&lt;&lt;1)#define rs ((rt)&lt;&lt;1|1)void read(int &amp;ret) { ret = 0; char ch = getchar(); while (!isdigit(ch)) ch = getchar(); while (isdigit(ch)) { ret = (ret&lt;&lt;1) + (ret&lt;&lt;3) + (ch^48); ch = getchar(); } return ;}void pushup(int rt) { val[rt] = (val[ls] + val[rs]) % Mod; return ;}void build(int rt, int l, int r) { if (l==r) { val[rt] = wl[l]; return ; } int mid = (l+r) &gt;&gt; 1; build(ls, l, mid); build(rs, mid+1, r); pushup(rt); return ;}void pushdown(int rt, int l, int r) { if (!lazy[rt]) return ; int mid = (l+r) &gt;&gt; 1; lazy[ls] += lazy[rt], lazy[rs] += lazy[rt]; lazy[ls] %= Mod, lazy[rs] %= Mod; val[ls] = (val[ls] + (mid-l+1) * lazy[rt]) % Mod; val[rs] = (val[rs] + (r-mid) * lazy[rt]) % Mod; lazy[rt] = 0; return ;}void upd(int rt, int l, int r, int L, int R, int f) { if (L&lt;=l &amp;&amp; r&lt;=R) { val[rt] += (r-l+1) * f, val[rt] %= Mod; lazy[rt] += f, lazy[rt] %= Mod; return ; } pushdown(rt, l, r); int mid = (l+r) &gt;&gt; 1; if (L&lt;=mid) upd(ls, l, mid, L, R, f); if (R&gt;mid) upd(rs, mid+1, r, L, R, f); pushup(rt); return ;}int query(int rt, int l, int r, int L, int R) { if (L&lt;=l &amp;&amp; r&lt;=R) return val[rt]; pushdown(rt, l, r); int mid = (l+r) &gt;&gt; 1, ans = 0; if (L&lt;=mid) ans += query(ls, l, mid, L, R); if (R&gt;mid) ans += query(rs, mid+1, r, L, R); return ans % Mod;}void dfs1(int cur, int f) { dep[cur] = dep[f] + 1; siz[cur] = 1, fa[cur] = f; int heavyson = -1; for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (to==f) continue; dfs1(to, cur), siz[cur] += siz[to]; if (siz[to]&gt;heavyson) heavyson = siz[to], son[cur] = to; } return ;}void dfs2(int cur, int Tp) { id[cur] = ++idx, wl[idx] = w[cur]; tp[cur] = Tp; if (!son[cur]) return ; dfs2(son[cur], Tp); for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (to==son[cur] || to==fa[cur]) continue; dfs2(to, to); } return ;}void up(int l, int r, int f) { f %= Mod; while (tp[l] ^ tp[r]) { if (dep[tp[l]] &lt; dep[tp[r]]) swap(l, r); upd(1, 1, n, id[tp[l]], id[l], f); l = fa[tp[l]]; } if (dep[l] &gt; dep[r]) swap(l, r); upd(1, 1, n, id[l], id[r], f); return ;}int qu(int l, int r) { int ans = 0; while (tp[l] ^ tp[r]) { if (dep[tp[l]] &lt; dep[tp[r]]) swap(l, r); ans = (ans + query(1, 1, n, id[tp[l]], id[l])) % Mod; l = fa[tp[l]]; } if (dep[l] &gt; dep[r]) swap(l, r); ans = (ans + query(1, 1, n, id[l], id[r])) % Mod; return ans;}void upsub(int x, int f) { upd(1, 1, n, id[x], id[x]+siz[x]-1, f); }int qusub(int x) { return query(1, 1, n, id[x], id[x]+siz[x]-1); }signed main() { read(n), read(m); read(root), read(Mod); for (int i=1; i&lt;=n; ++i) read(w[i]); for (int i=1; i&lt;n; ++i) { int u, v; read(u), read(v); addEdge(u, v); addEdge(v, u); } dfs1(root, root); dfs2(root, 0); build(1, 1, n); while (m--) { int opt, x, y, z; read(opt); if (opt==1) { read(x), read(y), read(z); up(x, y, z); } else if (opt==2) { read(x), read(y); printf(&quot;%lld\\n&quot;, qu(x, y) % Mod); } else if (opt==3) { read(x), read(z); upsub(x, z); } else { read(x); printf(&quot;%lld\\n&quot;, qusub(x) % Mod); } } return 0;} P2590 树的统计 更简单了，甚至不需要 lazytag。 代码如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;stdio.h&gt;#include &lt;iostream&gt;#define isdigit(ch) (ch&gt;47&amp;&amp;ch&lt;58)void read(int &amp;ret) { ret = 0; char ch = getchar(); int f = 1; while (!isdigit(ch) &amp;&amp; ch ^ '-') ch = getchar(); if (ch == '-') f = -1, ch = getchar(); while (isdigit(ch)) { ret = (ret&lt;&lt;1) + (ret&lt;&lt;3) + (ch^48); ch = getchar(); } ret *= f; return ;}void out(int ret) { if (ret&lt;0) { ret = -ret, putchar('-'); } if (ret&gt;9) out(ret/10); putchar(ret%10 ^ 48); return ;}const int N = 3e4 + 10;int n, Q, cnt, dfn;int w[N], v[N], head[N];int val[N&lt;&lt;2], siz[N], Maxi[N&lt;&lt;2];int id[N], fa[N], tp[N], son[N], dep[N];char str[10];int max(int x, int y) { return x&gt;y? x:y; }void swap(int &amp;x, int &amp;y) { x ^= y ^= x ^= y; }struct Edge { int to, nxt;} e[N&lt;&lt;1];#define ls ((rt)&lt;&lt;1)#define rs ((rt)&lt;&lt;1|1)void addEdge(int u, int v) { e[++cnt].to = v; e[cnt].nxt = head[u]; head[u] = cnt; return ;}void pushup(int rt) { val[rt] = val[ls] + val[rs]; Maxi[rt] = max(Maxi[ls], Maxi[rs]); return ;}void build(int rt, int l, int r) { if (l == r) { val[rt] = Maxi[rt] = v[l]; return ; } int mid = (l+r) &gt;&gt; 1; build(ls, l, mid); build(rs, mid+1, r); pushup(rt); return ;}void upd(int rt, int l, int r, int pos, int f) { if (l == r) { val[rt] = Maxi[rt] = f; return ; } int mid = (l+r) &gt;&gt; 1; if (pos&lt;=mid) upd(ls, l, mid, pos, f); if (pos&gt;mid) upd(rs, mid+1, r, pos, f); pushup(rt); return ;}int querys(int rt, int l, int r, int L, int R) { if (L&lt;=l &amp;&amp; r&lt;=R) return val[rt]; int mid = (l+r) &gt;&gt; 1, ans = 0; if (L&lt;=mid) ans += querys(ls, l, mid, L, R); if (R&gt;mid) ans += querys(rs, mid+1, r, L, R); return ans;}int querym(int rt, int l, int r, int L, int R) { if (L&lt;=l &amp;&amp; r&lt;=R) return Maxi[rt]; int mid = (l+r) &gt;&gt; 1, Max = -1e9; if (L&lt;=mid) Max = max(Max, querym(ls, l, mid, L, R)); if (R&gt;mid) Max = max(Max, querym(rs, mid+1, r, L, R)); return Max;}void dfs1(int cur, int Fa) { dep[cur] = dep[Fa] + 1; fa[cur] = Fa, siz[cur] = 1; int heavyson = -1; for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (to == Fa) continue; dfs1(to, cur); siz[cur] += siz[to]; if (siz[to] &gt; heavyson) son[cur] = to, heavyson = siz[to]; } return ;}void dfs2(int cur, int Tp) { id[cur] = ++dfn; v[dfn] = w[cur], tp[cur] = Tp; if (!son[cur]) return ; dfs2(son[cur], Tp); for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (to == fa[cur] || to == son[cur]) continue; dfs2(to, to); } return ;}int qus(int l, int r) { int ans = 0; while (tp[l] ^ tp[r]) { if (dep[tp[l]] &lt; dep[tp[r]]) swap(l, r); int cur = querys(1, 1, n, id[tp[l]], id[l]); ans += cur, l = fa[tp[l]]; } if (dep[l] &gt; dep[r]) swap(l, r); ans += querys(1, 1, n, id[l], id[r]); return ans;}int qum(int l, int r) { int ans = -1e9; while (tp[l] ^ tp[r]) { if (dep[tp[l]] &lt; dep[tp[r]]) swap(l, r); int cur = querym(1, 1, n, id[tp[l]], id[l]); ans = max(ans, cur), l = fa[tp[l]]; } if (dep[l] &gt; dep[r]) swap(l, r); ans = max(ans, querym(1, 1, n, id[l], id[r])); return ans;}int main() {// freopen(&quot;P2590.in&quot;, &quot;r&quot;, stdin);// freopen(&quot;P2590.out&quot;, &quot;w&quot;, stdout); read(n); for (int i=1; i&lt;n; ++i) { int x, y; read(x), read(y); addEdge(x, y), addEdge(y, x); } for (int i=1; i&lt;=n; ++i) read(w[i]); dfs1(1, 1), dfs2(1, 1); build(1, 1, n); read(Q); while (Q--) { std::cin &gt;&gt; str+1; int l, r; read(l), read(r); if (str[1] == 'C') upd(1, 1, n, id[l], r); else if (str[2] == 'M') out(qum(l, r)), puts(&quot;&quot;); else if (str[2] == 'S') out(qus(l, r)), puts(&quot;&quot;); } return 0;} P2146 软件包管理器 简单 trick。 只需要将依赖关系转化为树上关系就可以了。然后就是要区分 0 和 unedited，完全不一样。所以可以直接将 unedited 设置为 -1 然后乱搞即可。 注意是赋值而不是加法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;bits/stdc++.h&gt;using namespace std;void read(int &amp;ret) { ret = 0; char ch = getchar(); while (!isdigit(ch)) ch = getchar(); while (isdigit(ch)) { ret = (ret&lt;&lt;1) + (ret&lt;&lt;3) + (ch^48); ch = getchar(); } return ;}const int N = 1e5 + 10;int n, Q, cnt, idx, head[N];int val[N&lt;&lt;2], lazy[N&lt;&lt;2];int id[N], tp[N], siz[N], dep[N];char opt[20]; int fa[N], son[N];struct Edge { int to, nxt; } e[N];void addEdge(int u, int v) { e[++cnt].to = v; e[cnt].nxt = head[u]; head[u] = cnt; return ;}#define ls ((rt)&lt;&lt;1)#define rs ((rt)&lt;&lt;1|1)void pushup(int rt) { val[rt] = val[ls] + val[rs]; return ;}void pushdown(int rt, int l, int r) { if (lazy[rt]&lt;0) return ; int mid = (l+r) &gt;&gt; 1; lazy[ls] = lazy[rt], lazy[rs] = lazy[rt]; val[ls] = lazy[rt] * (mid-l+1); val[rs] = lazy[rt] * (r-mid); lazy[rt] = -1; return ;}void upd(int rt, int l, int r, int L, int R, int f) { if (L&lt;=l &amp;&amp; r&lt;=R) { lazy[rt] = f; val[rt] = f * (r-l+1); return ; } pushdown(rt, l, r); int mid = (l+r) &gt;&gt; 1; if (L&lt;=mid) upd(ls, l, mid, L, R, f); if (R&gt;mid) upd(rs, mid+1, r, L, R, f); pushup(rt); return ;}int query(int rt, int l, int r, int L, int R) { if (L&lt;=l &amp;&amp; r&lt;=R) return val[rt]; pushdown(rt, l, r); int mid = (l+r) &gt;&gt; 1, ans = 0; if (L&lt;=mid) ans += query(ls, l, mid, L, R); if (R&gt;mid) ans += query(rs, mid+1, r, L, R); return ans;}void dfs1(int cur, int f) { dep[cur] = dep[f] + 1; fa[cur] = f, siz[cur] = 1; int heavyson = -1; for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; dfs1(to, cur), siz[cur] += siz[to]; if (siz[to] &gt; heavyson) heavyson = siz[to], son[cur] = to; } return ;}void dfs2(int cur, int Tp) { id[cur] = ++idx; tp[cur] = Tp; if (!son[cur]) return ; dfs2(son[cur], Tp); for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (to==son[cur]) continue; dfs2(to, to); } return ;}void up(int l, int r, int f) { while (tp[l] ^ tp[r]) { if (dep[tp[l]] &lt; dep[tp[r]]) swap(l, r); upd(1, 1, n, id[tp[l]], id[l], f); l = fa[tp[l]]; } if (dep[l] &gt; dep[r]) swap(l, r); upd(1, 1, n, id[l], id[r], f); return ;}int main() {// freopen(&quot;P2146.in&quot;, &quot;r&quot;, stdin); memset(lazy, -1, sizeof lazy); read(n); for (int i=2; i&lt;=n; ++i) { int v; read(v); addEdge(v+1, i); } dfs1(1, 1), dfs2(1, 1), read(Q); while (Q--) { cin &gt;&gt; opt+1; int v; read(v); ++v; int cur = query(1, 1, n, 1, n); if (opt[1]=='i') up(1, v, 1); else if (opt[1]=='u') upd(1, 1, n, id[v], id[v]+siz[v]-1, 0); int to = query(1, 1, n, 1, n); printf(&quot;%d\\n&quot;, abs(cur-to)); } return 0;} P3178 树上操作 也是个简单题，就是不要被 from 和 to 骗了，双向边肯定要连的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;void read(int &amp;ret) { ret = 0; char ch = getchar(); int f = 1; while (!isdigit(ch) &amp;&amp; ch^'-') ch = getchar(); if (ch=='-') f = -1, ch = getchar(); while (isdigit(ch)) { ret = (ret&lt;&lt;1) + (ret&lt;&lt;3) + (ch^48); ch = getchar(); } ret *= f; return ;}const int N = 1e5 + 10;int n, m, cnt, idx;int dep[N], son[N], fa[N], siz[N];int head[N&lt;&lt;1], tp[N], w[N], wl[N], id[N];struct Edge { int to, nxt; } e[N&lt;&lt;1];void addEdge(int u, int v) { e[++cnt].to = v; e[cnt].nxt = head[u]; head[u] = cnt; return ;}int lazy[N&lt;&lt;2], val[N&lt;&lt;2];#define ls ((rt)&lt;&lt;1)#define rs ((rt)&lt;&lt;1|1)void pushup(int rt) { val[rt] = val[ls] + val[rs]; return ;}void build(int rt, int l, int r) { if (l==r) { val[rt] = wl[l]; return ; } int mid = (l+r) &gt;&gt; 1; build(ls, l, mid); build(rs, mid+1, r); pushup(rt); return ;}void pushdown(int rt, int l, int r) { if (!lazy[rt]) return ; int mid = (l+r) &gt;&gt; 1; lazy[ls] += lazy[rt], lazy[rs] += lazy[rt]; val[ls] += (mid-l+1) * lazy[rt]; val[rs] += (r-mid) * lazy[rt]; lazy[rt] = 0; return ;}void upd(int rt, int l, int r, int L, int R, int f) { if (L&lt;=l &amp;&amp; r&lt;=R) { lazy[rt] += f; val[rt] += f * (r-l+1); return ; } int mid = (l+r) &gt;&gt; 1; pushdown(rt, l, r); if (L&lt;=mid) upd(ls, l, mid, L, R, f); if (R&gt;mid) upd(rs, mid+1, r, L, R, f); pushup(rt); return ;}int query(int rt, int l, int r, int L, int R) { if (L&lt;=l &amp;&amp; r&lt;=R) return val[rt]; int ans = 0, mid = (l+r) &gt;&gt; 1; pushdown(rt, l, r); if (L&lt;=mid) ans += query(ls, l, mid, L, R); if (R&gt;mid) ans += query(rs, mid+1, r, L, R); return ans;}void dfs1(int cur, int f) { fa[cur] = f, siz[cur] = 1; dep[cur] = dep[f] + 1; int heavyson = -1; for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (to==f) continue; dfs1(to, cur); siz[cur] += siz[to]; if (siz[to] &gt; heavyson) heavyson = siz[to], son[cur] = to; } return ;}void dfs2(int cur, int Tp) { id[cur] = ++idx, wl[idx] = w[cur]; tp[cur] = Tp; if (!son[cur]) return ; dfs2(son[cur], Tp); for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (to==fa[cur] || to==son[cur]) continue; dfs2(to, to); } return ;}int que(int l, int r) { int ans = 0; while (tp[l] ^ tp[r]) { if (dep[tp[l]] &lt; dep[tp[r]]) swap(l, r); ans += query(1, 1, n, id[tp[l]], id[l]); l = fa[tp[l]]; } if (dep[l] &gt; dep[r]) swap(l, r); ans += query(1, 1, n, id[l], id[r]); return ans;}signed main() { read(n), read(m); for (int i=1; i&lt;=n; ++i) read(w[i]); for (int i=1; i&lt;n; ++i) { int u, v; read(u), read(v); addEdge(u, v); addEdge(v, u); } dfs1(1, 1), dfs2(1, 1); build(1, 1, n); while (m--) { int opt, x, a; read(opt), read(x); if (opt==1) { read(a); upd(1, 1, n, id[x], id[x], a); } else if (opt==2) { read(a); upd(1, 1, n, id[x], id[x]+siz[x]-1, a); } else printf(&quot;%lld\\n&quot;, que(1, x)); } return 0;}","link":"/2021/08/03/DS-On-Tree/"},{"title":"CF961G Solution","text":"CF961G Partitions 这题好神啊 … 我发现我一直 WA5 的原因是开始统计和的时候没有取模（然后就想着写篇题解记录一下 … 首先题目不是要求一个和吗。 那么通过人类智慧发现很显然所有数出现的次数都是一样的。也就是说最后的和式必然是 $…\\times \\sum\\limits_{i=1}^nw_i$ 这样的形式。 那么不妨将前面的系数设为 $p$。 我们对于这个问题其实可以用 DP 的思想来解决。我们对于求整个柿子的系数，直接考虑枚举子集大小。然后就可以发现我们当前选了 $i$ 个，然后算出自己集合的方案和别的集合的方案即可。最后相乘累加就是答案，其中运用的是第二类斯特林数的思想。 第二类斯特林数就解决的是这样一类问题： $n$ 个物品放入 $m$ 个不同集合中，求集合非空的总方案数。 想要研究的同学可以自行研究，这里不再赘述。 所以就可以得到系数 $p$ 变成了下面的柿子。 $$p=\\sum\\limits_{i=1}^ni\\binom{n-1}{i-1}S_2(n-i,k-1)\\=\\sum\\limits_{i=1}^ni\\binom{n-1}{i-1}\\dfrac{1}{(k-1)!}\\sum\\limits_{j=0}^{k-1}(-1)^j\\binom{k-1}{j}(k-j-1)^{n-i}\\=\\sum\\limits_{i=1}^ni\\binom{n-1}{i-1}\\dfrac{1}{(k-1)!}\\sum\\limits_{j=0}^{k-1}(-1)^j\\dfrac{(k-1)!}{j!\\times(k-j-1)!}(k-j-1)^{n-i}\\=\\sum\\limits_{i=1}^ni\\binom{n-1}{i-1}\\sum\\limits_{j=0}^{k-1}\\dfrac{(-1)^j(k-j-1)^{n-i}}{j!\\times(k-j-1)!}\\=\\sum\\limits_{j=0}^{k-1}\\dfrac{(-1)^j}{j!\\times(k-j-1)!}\\sum\\limits_{i=1}^ni\\binom{n-1}{i-1}(k-j-1)^{n-i}$$ 注意上面将 $j$的和式提前了，这显然是正确的。因为分母相同相加分母不变，然后 $-1$ 的系数显然只和 $j$ 有关。但是分子剩下的部分 $(k-j-1)^{n-i}$ 显然和 $i$ 和 $j$ 都有关。所以为了方便后面的推导，这里直接将 $j$ 提前作为后面那一堆和的系数。这里说的 方便推导 其实也没有什么非常清晰的界定，只是这部分可以简单解决。当然不排除有暴力老哥直接卷的情况。（其实我也不知道可不可以卷，因为我没学多项式（（ 所以看到一大堆阶乘，在保证答案正确性的情况下，直接从一大堆柿子里面拎出来是必要的。 然后后面那个 $(k-j-1)$ 看起来特别丑，弄成 $s$。 $$\\sum\\limits_{i=1}^ni\\binom{n-1}{i-1}s^{n-i}\\=\\sum\\limits_{i=1}^ni\\times s^{n-i}\\dfrac{(n-1)!}{(i-1)! \\times (n-i)!}$$ 为了约分上面的组合数拆开了。 然后有一个 trick，看到分母有一个 $i-1$，看到前面的系数 $i$，所以把那个 $i$ 给拆掉，拆成 $i=i-1+1$。 所以有 $$=\\sum\\limits_{i=1}^ns^{n-i}\\times(i-1+1)\\dfrac{(n-1)!}{(i-1)! \\times (n-i)!}\\=\\sum\\limits_{i=1}^ns^{n-i}[(i-1)\\times \\dfrac{(n-1)!}{(i-1)! \\times (n-i)!}+\\dfrac{(n-1)!}{(i-1)! \\times (n-i)!}]\\=\\sum\\limits_{i=1}^ns^{n-i}(i-1)\\dfrac{(n-1)!}{(i-1)! \\times (n-i)!}+\\sum\\limits_{i=1}^ns^{n-i}\\dfrac{(n-1)!}{(i-1)! \\times (n-i)!}$$ 然后约掉共同的 $i-1$。 $$=\\sum\\limits_{i=1}^ns^{n-i}\\dfrac{(n-1)!}{(i-2)! \\times (n-i)!}+\\sum\\limits_{i=1}^n\\dfrac{(n-1)!}{(i-1)! \\times (n-i)!}$$ 再重新写成方便的组合数形式。 $$=\\sum\\limits_{i=1}^ns^{n-i}\\binom{n-1}{i-2}+\\sum_{i=1}^ns^{n-i}\\binom{n-1}{i-1}$$ 由于这个上下不统一所以把 $(n-1)$ 提出来。 $$=(n-1)\\sum\\limits_{i=1}^ns^{n-i}\\binom{n-2}{i-2}+\\sum\\limits_{i=1}^ns^{n-i}\\binom{n-1}{i-1}$$ 然后发现这个玩意儿好像很不好算，所以变成下面这样，因为 $\\binom{n}{m}=\\binom{n}{n-m}$。 $$=(n-1)\\sum\\limits_{i=1}^ns^{n-i}\\binom{n-2}{n-i}+\\sum\\limits_{i=1}^ns^{n-i}\\binom{n-1}{n-i}$$ 然后根据那个什么柿子的展开，就是杨辉三角的系数，观察到 $n-i$ 的共同部分可以运用上这个公式，可以发现这个可以直接把组合数拆开变成幂。 实际上那个 $\\sum\\limits_{i=1}^n$ 有一些项应该是不能算的，因为组合数其实等于 $0$。所以根据 $(a+b)^n$ 的系数其实就是组合数，可以直接代进去。 即 $(a+b)^n=\\sum\\limits_{i=0}^n\\binom{n}{i}a^{n-i}b^i$。 应该长成这样吧，不太确定有没有问题。 所以又可以化简成下面那样。 $$=(n-1)(s+1)^{n-2}+(s+1)^{n-1}\\=(s+1)^{n-2}(s+1+n-1)\\=(s+1)^{n-2}(s+n)$$ 然后就可以代回去了。 $$p=\\sum\\limits_{j=0}^{k-1}\\dfrac{(-1)^j}{j!\\times(k-j-1)!}[(n-1)(k-j)^{n-2}+(k-j)^{n-1}]\\=\\sum\\limits_{j=0}^{k-1}\\dfrac{(-1)^j}{j!\\times(k-j-1)!}(k-j)^{n-2}(n+k-j-1)$$ 所以就可以得出代码了。我的时间复杂度比较劣，代码还是参考别人的吧。 时间复杂度 $\\Theta(k \\log \\text{Mod})$。 不要问我为什么后面是 $\\text{Mod}$ 而不是 $n$（问就是逆元没有线性求，直接 qpow(x,mod-2)（（（ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 2e5 + 10;const int MOD = 1e9 + 7;int n, k, cnt, sum, a, jc[N];void init() { jc[0] = jc[1] = 1ll; for (int i=2; i&lt;=k; ++i) jc[i] = jc[i-1] * i % MOD; // 预处理阶乘 return ;}int qpow(int bas, int pw) { int mult = 1ll; while (pw) { if (pw &amp; 1ll) mult = mult * bas % MOD; bas = bas * bas % MOD; pw /= 2; // 貌似是个 UB，不能写 &gt;&gt;=1ll } return mult;}int inv(int x) { return qpow(x, MOD-2); }signed main() {// freopen(&quot;sum.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;sum.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%lld%lld&quot;, &amp;n, &amp;k); init(); for (int i=1; i&lt;=n; ++i) scanf(&quot;%lld&quot;, &amp;a), cnt = (cnt + a) % MOD; int Sum = 0; for (int i=0; i&lt;k; ++i) { int cur = inv(jc[i]); cur = cur * inv(jc[k-i-1]) % MOD; int f = i&amp;1? -1 : 1; cur = f * cur % MOD, cur = (cur % MOD + MOD) % MOD; cur = cur * qpow(k-i, n-2) % MOD; cur = cur * (n+k-i-1) % MOD; Sum = (Sum + cur) % MOD; // 对于分母求逆元再乘分子，基本操作 } cout &lt;&lt; Sum * cnt % MOD &lt;&lt; endl; return 0;}","link":"/2021/08/04/CF961G-Solution/"},{"title":"Introduction","text":"First of all, this is my first successful hexo Blog!I may be a pigeon in the future … u1s1 hexo is better than Gridea …And maybe I will put my Luogu Blog away qaq Test for Markdown &amp; LaTeX$$\\sum\\limits_{i=1}^na_i$$","link":"/2021/08/02/Introduction/"},{"title":"Kill Network-Flows","text":"P2756 飞行员配对方案问题 只要默认前面 $m$ 个都是外国的，然后剩下的都是英国的，接着暴力建图跑 Dinic 即可。貌似只需要弄一个源点 $0$ 和汇点 $n+1$ 即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;const int N = 2e4 + 10;int n, m, cnt = 1;int head[N], dep[N];bool vis[N];struct Edge { int to, nxt, val;} e[N];void addEdge(int u, int v, int w) { e[++cnt].to = v; e[cnt].nxt = head[u]; e[cnt].val = w; head[u] = cnt; return ;}bool check() { for (int i=0; i&lt;=n+1; ++i) dep[i] = 0; dep[0] = 2; queue &lt;int&gt; sp; sp.push(0); while (!sp.empty()) { int cur = sp.front(); sp.pop(); for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (!dep[to] &amp;&amp; e[i].val) { dep[to] = dep[cur] + 1, sp.push(to); if (to==n+1) return true; } } } return false;}int dfs(int cur, int Max) { if (cur==n+1) return Max; int increase = Max; for (int i=head[cur]; i&amp;&amp;increase; i=e[i].nxt) { int to = e[i].to; if (e[i].val &amp;&amp; dep[to]==dep[cur]+1) { int res = dfs(to, min(increase, e[i].val)); e[i].val -= res, e[i^1].val += res; if (!res) dep[to] = 0; increase -= res; } } return Max-increase;}void read(int &amp;ret) { ret = 0; char ch = getchar(); int f = 1; while (!isdigit(ch) &amp;&amp; ch^'-') ch = getchar(); if (ch=='-') f = -1, ch = getchar(); while (isdigit(ch)) { ret = (ret&lt;&lt;1) + (ret&lt;&lt;3) + (ch^48); ch = getchar(); } ret *= f; return ;}int main() { read(m), read(n); while (1) { int u, v; read(u), read(v); if (u==-1 &amp;&amp; v==-1) break; addEdge(u, v, inf); addEdge(v, u, 0); } for (int i=1; i&lt;=m; ++i) addEdge(0, i, 1), addEdge(i, 0, 0); for (int i=m+1; i&lt;=n; ++i) addEdge(i, n+1, 1), addEdge(n+1, i, 0); int ans = 0; while(check()) ans += dfs(0, inf); cout &lt;&lt; ans &lt;&lt; endl; for (int i=2; i&lt;=cnt; i+=2) { if (!e[i^1].val) continue; if (!e[i].to || !e[i^1].to) continue; if (e[i].to==n+1) continue; if (e[i^1].to==n+1) continue; printf(&quot;%d %d\\n&quot;, e[i^1].to, e[i].to); } return 0;} P1251 餐巾计划问题 这道题最重要的是连边。那么很显然的拆点技巧，将一天拆成服务和收工两个点，即 i+N 和 i，后前两个点。那么源点为 0，汇点为 2*N+1。 要购买餐巾 显然从源点处购买，直接建边 add(0,i+N,inf,p)。 偷懒先不洗餐巾 显然直接延到下一天，add(i,i+1,inf,0)。 快洗 显然直接丢到 $m$ 天后，add(i,i+N+m,inf,f)。 慢洗 同理丢到 $n$ 天后，add(i,i+N+n,inf,s)。 然后每一天要跑至少为 r[i] 的流量，直接源点连收工，汇点连服务。 然后跑一遍最小费用最大流即可。 nt 的地方：DFS 要标记 cur，数组不要开小。要是写对了正解然后数组开小了那就真的是个 zz。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int MAXN = 2e3 + 10;const int inf = 2e9;int N, cnt = 1, head[MAXN*12];int p, m, f, n, s, dist[MAXN*12];bool inq[MAXN*2], vis[MAXN*2];int cost;struct Edge { int to, nxt, flow, val;} e[MAXN*12];void addEdge(int u, int v, int f, int w) { e[++cnt].to = v; e[cnt].nxt = head[u]; e[cnt].flow = f, e[cnt].val = w; head[u] = cnt; e[++cnt].to = u; e[cnt].nxt = head[v]; e[cnt].flow = 0, e[cnt].val = -w; head[v] = cnt; return ;}void read(int &amp;ret) { ret = 0; char ch = getchar(); while (!isdigit(ch)) ch = getchar(); while (isdigit(ch)) { ret = (ret&lt;&lt;1) + (ret&lt;&lt;3) + (ch^48); ch = getchar(); } return ;}bool spfa() { for (int i=0; i&lt;=2*N+1; ++i) dist[i] = inf, inq[i] = false; dist[0] = 0, inq[0] = true; queue &lt;int&gt; sp; sp.push(0); while (!sp.empty()) { int cur = sp.front(); sp.pop(); inq[cur] = false; for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (e[i].flow &amp;&amp; dist[to]&gt;dist[cur]+e[i].val) { dist[to] = dist[cur] + e[i].val; if (!inq[to]) inq[to] = true, sp.push(to); } } } return dist[2*N+1] &lt; inf;}int dfs(int cur, int Max) { if (cur == 2*N+1) { vis[cur] = true; return Max; } int increase = Max; vis[cur] = true; for (int i=head[cur]; i &amp;&amp; increase; i=e[i].nxt) { int to = e[i].to; if ((!vis[to] || to==MAXN) &amp;&amp; e[i].flow &amp;&amp; dist[to]==dist[cur]+e[i].val) { int res = dfs(to, min(increase, e[i].flow)); if (!res) continue; e[i].flow -= res, e[i^1].flow += res; cost += res * e[i].val, increase -= res; } } return Max-increase;}signed main() { cin &gt;&gt; N; for (int i=1; i&lt;=N; ++i) { int r; cin &gt;&gt; r; addEdge(0, i, r, 0); addEdge(i+N, 2*N+1, r, 0); } cin &gt;&gt; p &gt;&gt; m &gt;&gt; f &gt;&gt; n &gt;&gt; s; // begin point: i // ending point: i+N for (int i=1; i&lt;=N; ++i) { addEdge(0, i+N, inf, p); if (i&lt;N) addEdge(i, i+1, inf, 0); if (i+m&lt;=N) addEdge(i, i+N+m, inf, f); if (i+n&lt;=N) addEdge(i, i+N+n, inf, s); } while (spfa()) { for (int i=0; i&lt;=2*N+1; ++i) vis[i] = false; dfs(0, inf); } cout &lt;&lt; cost &lt;&lt; endl; return 0;} P4011 孤岛营救问题 这道题为什么要网络流啊。 难道不是直接暴力 BFS 寻找路径吗？ 直接状压一下钥匙，然后每一次到达门就看有没有钥匙就可以了。 nt 的地方：x(x), y(y) 写成了 x(x), y(x) … … 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 11;const int dx[] = {0, 1, 0, -1};const int dy[] = {1, 0, -1, 0};int n, m, p, k, s, door[N][N][N][N];int cnt[N][N], key[N][N][N];bool vis[N][N][1&lt;&lt;N];struct spread { int x, y, Key, cost; spread(int x, int y, int Key, int cost): x(x), y(y), Key(Key), cost(cost) {} spread() {}};int keyset(int x, int y) { int S = 0; for (int i=1; i&lt;=cnt[x][y]; ++i) S |= (1&lt;&lt;(key[x][y][i]-1)); return S;}bool check(int x, int y, int k, int st) { if (x&lt;1 || x&gt;n) return false; if (y&lt;1 || y&gt;m) return false; if (k&lt;0 || (k &amp;&amp; !(st&amp;(1&lt;&lt;(k-1))))) return false; return true;}int bfs() { int x = 1, y = 1; int S = keyset(x, y); queue &lt;spread&gt; que; que.push(spread(x, y, S, 0)); vis[x][y][S] = true; while (!que.empty()) { spread cur = que.front(); que.pop(); x = cur.x, y = cur.y, S = cur.Key; if (x==n &amp;&amp; y==m) return cur.cost; for (int i=0; i&lt;4; ++i) { int tox = x + dx[i], toy = y + dy[i]; int Door = door[x][y][tox][toy]; if (!check(tox, toy, Door, S)) continue; int to = S|keyset(tox, toy); if (vis[tox][toy][to]) continue; vis[tox][toy][to] = true; que.push(spread(tox, toy, to, cur.cost+1)); } } return -1;}int main() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; p &gt;&gt; k; while (k--) { int x, y, X, Y, G; cin &gt;&gt; x &gt;&gt; y &gt;&gt; X &gt;&gt; Y &gt;&gt; G; if (G) door[x][y][X][Y] = door[X][Y][x][y] = G; else door[x][y][X][Y] = door[X][Y][x][y] = -1; } cin &gt;&gt; s; while (s--) { int x, y, Q; cin &gt;&gt; x &gt;&gt; y &gt;&gt; Q; key[x][y][++cnt[x][y]] = Q; } cout &lt;&lt; bfs() &lt;&lt; endl; return 0;} P2764 最小路径覆盖问题 众所周知最小路径覆盖 $=$ 顶点数 $-$ 最大匹配数，这个是很显然的。 Proof：因为对于每一个点一开始都可以作为一条路径，所以一开始就有 $n$ 条路径。因为每一次匹配相当于把两个点合并，所以路径条数相当于减掉了 $1$，所以最大匹配数就是合并的个数，所以最后就是 $n-$最大匹配数。又因为二分图可以网络流乱搞，所以路径覆盖也可以网络流乱搞。 所以正常的 trick，拆点跑最大流。路径输出比较正常，直接在 DFS 的时候找到起始点然后记录路径即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;void read(int &amp;ret) { ret = 0; char ch = getchar(); while (!isdigit(ch)) ch = getchar(); while (isdigit(ch)) { ret = (ret&lt;&lt;1) + (ret&lt;&lt;3) + (ch^48); ch = getchar(); } return ;}const int N = 1e5 + 10;const int inf = 1e9;int n, m, s, t, cnt = 1;int dep[N], head[N]; bool inq[N];int cost, path[N]; bool vis[N];struct Edge { int to, nxt, flow;} e[N];void addEdge(int u, int v, int f) { e[++cnt].to = v; e[cnt].nxt = head[u]; e[cnt].flow = f; head[u] = cnt; e[++cnt].to = u; e[cnt].nxt = head[v]; e[cnt].flow = 0; head[v] = cnt; return ;}bool check() { for (int i=0; i&lt;=t; ++i) dep[i] = inf, inq[i] = false; dep[s] = 0; queue &lt;int&gt; sp; sp.push(s); inq[s] = true; while (!sp.empty()) { int cur = sp.front(); sp.pop(); for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (e[i].flow &amp;&amp; dep[to]==inf) { dep[to] = dep[cur] + 1, sp.push(to); } } } return dep[t] ^ inf;}int dfs(int cur, int Max) { if (cur==t) return Max; int increase = Max; for (int i=head[cur]; i &amp;&amp; increase; i=e[i].nxt) { int to = e[i].to; if (e[i].flow &amp;&amp; dep[to]==dep[cur]+1) { int res = dfs(to, min(increase, e[i].flow)); if (!res) { dep[to] = -1; continue; } e[i].flow -= res, e[i^1].flow += res; path[cur] = to; if (cur) vis[to-n] = true; increase -= res; } } return Max-increase;}int main() { cin &gt;&gt; n &gt;&gt; m; t = 2*n+1; for (int i=1; i&lt;=m; ++i) { int u, v; cin &gt;&gt; u &gt;&gt; v; addEdge(u, n+v, 1); } for (int i=1; i&lt;=n; ++i) addEdge(s, i, 1); for (int i=1; i&lt;=n; ++i) addEdge(i+n, t, 1); int ans = 0; while (check()) ans += dfs(s, inf); for (int i=1; i&lt;=n; ++i) { if (vis[i]) continue; int cur = i; cout &lt;&lt; i; while(path[cur] &amp;&amp; path[cur]^t) cout &lt;&lt; ' ' &lt;&lt; path[cur]-n, cur = path[cur]-n; cout &lt;&lt; endl; } cout &lt;&lt; n-ans &lt;&lt; endl; return 0;} P4016 负载平衡问题 听名字还挺高大上的。 其实就是个卡牌游戏啊，只不过每一次只可以交换环上相邻两个。那么直接断环成链，拿原数减掉最后的固定答案然后前缀和加到 ans。 顺带卡了下常，12ms 最优解 Rank1。 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;int n, sum, ans, a[110], Sum[110];int abs(int x) { return x&gt;0? x:-x; }void qsort(int l, int r) { int mid = Sum[(l+r)&gt;&gt;1]; int i=l, j=r; do { while (Sum[i]&lt;mid) ++i; while (Sum[j]&gt;mid) --j; if(i&lt;=j) { int u=Sum[i]; Sum[i]=Sum[j]; Sum[j]=u; i++, j--; } } while (i&lt;=j); if (l&lt;j) qsort(l, j); if (i&lt;r) qsort(i, r); return ;}int main() { scanf(&quot;%d&quot;, &amp;n); for (int i=1; i&lt;=n; ++i) scanf(&quot;%d&quot;, &amp;a[i]), sum += a[i]; sum /= n; for (int i=1; i&lt;=n; ++i) Sum[i] = Sum[i-1]+a[i]-sum, a[i] = Sum[i]; qsort(1, n); int mid = n/2+1; for (int i=1; i&lt;=n; ++i) ans += abs(Sum[mid]-Sum[i]); printf(&quot;%d\\n&quot;, ans); return 0;} UVA11380 Down Went The Titanic 简单题。 首先看到点有限制，直接拆点。 那么因为没有给出单源点和汇点，分别建一个。 接着可以将 * 视为连向源点，所以边权为 $1$。同理 # 视为连向汇点，边权为限制 $p$。 然后因为 . 只能踩一次，所以拆成两个点，两个点之间的限制为 $1$。@ 可以踩无数次，所以连 INF。 接着因为周边四个点都可以扩展到（除起始点和水显然不可以扩展）。所以连容量为 INF 的边。 然后跑一遍最大流。 记得多测 cnt 要赋成 $1$ 而不是 $0$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 10;const int inf = 1e9;const int dx[4] = {1, 0, -1, 0};const int dy[4] = {0, 1, 0, -1};int n, m, p, s, t, cnt = 1;int dep[N], head[N]; char ch[40][40];struct Edge { int to, nxt, flow;} e[N];void addEdge(int u, int v, int f) { e[++cnt].to = v, e[cnt].nxt = head[u]; e[cnt].flow = f, head[u] = cnt; e[++cnt].to = u, e[cnt].nxt = head[v]; e[cnt].flow = 0, head[v] = cnt;}bool check(int x, int y) { return x&lt;1 || x&gt;n || y&lt;1 || y&gt;m;}void init() { cnt = 1; t = 2*n*m + 1; for (int i=1; i&lt;=n; ++i) for (int j=1; j&lt;=m; ++j) cin &gt;&gt; ch[i][j]; memset(head, -1, sizeof head); return ;}int id(int x, int y) { return (x-1)*m+y; }bool spfa() { for (int i=s; i&lt;=t; ++i) dep[i] = inf; dep[s] = 0; queue &lt;int&gt; sp; sp.push(s); while (!sp.empty()) { int cur = sp.front(); sp.pop(); for (int i=head[cur]; ~i; i=e[i].nxt) { int to = e[i].to; if (e[i].flow &amp;&amp; dep[to]==inf) { dep[to] = dep[cur] + 1, sp.push(to); } } } return dep[t]^inf;}int dfs(int cur, int Max) { if (cur==t) return Max; int increase = Max; for (int i=head[cur]; ~i &amp;&amp; increase; i=e[i].nxt) { int to = e[i].to; if (e[i].flow &amp;&amp; dep[to]==dep[cur]+1) { int res = dfs(to, min(increase, e[i].flow)); if (!res) continue; e[i].flow -= res, e[i^1].flow += res; increase -= res; } } return Max-increase;}int main() { while (scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;p) != EOF) { init(); int siz = n*m; for (int i=1; i&lt;=n; ++i) { for (int j=1; j&lt;=m; ++j) { if (ch[i][j] == '~') continue; if (ch[i][j] == '*') addEdge(s, id(i,j), 1); if (ch[i][j] == '.') addEdge(id(i,j), id(i,j)+siz, 1); if (ch[i][j] == '#') addEdge(id(i,j), t, p); for (int k=0; k&lt;4; ++k) { int tox = i+dx[k], toy = j+dy[k]; if (check(tox, toy)) continue; if (ch[tox][toy] == '*' || ch[tox][toy] == '~') continue; if (ch[i][j] == '.') addEdge(id(i,j)+siz, id(tox, toy), inf); else addEdge(id(i,j), id(tox, toy), inf); } } } int ans = 0; while (spfa()) ans += dfs(s, inf); cout &lt;&lt; ans &lt;&lt; endl; } return 0;}","link":"/2021/08/02/Kill-Network-Flows/"},{"title":"差分约束重提","text":"P5960 差分约束算法 显然题。 首先有 $x_{c1}-x_{c1’} \\le y_1$。那么有 $x_{c1} \\le x_{c1’} + y_1$。所以看到图论里面的松弛操作，即最终使得 dist[to]&lt;=dist[cur]+e[i].val。 要使得这个成立所以要跑一遍最短路。 那么将 $x$ 视为 dist，c1 视为 to，c1' 视为 cur 即可。 然后因为跑最短路的 dijkstra 需要源点，即单源最短路径。所以直接造一个源点就可以跑了，并没有什么实际作用（ 判负环似乎只需要加上一个统计入队次数的 cnt 即可。因为显然，有负环就没有合法解。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e3 + 10;int n, m, cnt; bool inq[N];int head[N&lt;&lt;1], dist[N], vis[N];struct Edge { int to, nxt, val;} e[N&lt;&lt;1];void addEdge(int u, int v, int w) { e[++cnt].to = v; e[cnt].nxt = head[u]; e[cnt].val = w; head[u] = cnt; return ;}bool spfa() { queue &lt;int&gt; sp; sp.push(0); vis[0] = 1, inq[0] = true; memset(dist, 0x3f, sizeof dist); dist[0] = 0; while (!sp.empty()) { int cur = sp.front(); sp.pop(); inq[cur] = false; for (int i=head[cur]; ~i; i=e[i].nxt) { int to = e[i].to; if (dist[to] &gt; dist[cur]+e[i].val) { dist[to] = dist[cur] + e[i].val; if (!inq[to]) { inq[to] = true, sp.push(to); ++vis[to]; if (vis[to]&gt;n) return true; } } } } return false;}int main() { memset(head, -1, sizeof head); cin &gt;&gt; n &gt;&gt; m; for (int i=1; i&lt;=m; ++i) { int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; addEdge(v, u, w); } for (int i=1; i&lt;=n; ++i) addEdge(0, i, 0); if (spfa()) { puts(&quot;NO&quot;); return 0; } for (int i=1; i&lt;=n; ++i) cout &lt;&lt; dist[i] &lt;&lt; ' '; return 0;}","link":"/2021/08/03/System-of-Difference-Constraints/"},{"title":"P2150 Solution","text":"P2150 寿司晚宴 Simplification for the Question 有 $[2,n]$ 总共 $n-1$ 个数。 从中挑选一些不重复的数字（可以不全选），组成集合 $S$ 和 $T$。 求使得 $\\forall x \\in S,y \\in T,\\gcd(x,y)=1$ 的方案总数。 Part 1 - 30pts Algorithm首先看到最简单的 30pts 算法，最暴力的部分总能给我们启示。 对于这 30pts，观察到 $n \\le 30$。 那么这意味着什么呢？对，就是暴力。 首先看到 $\\gcd$，求最大公约数，由唯一分解定理可知每一个数都可以由若干质数或质数的幂的连乘积构成，那么显然问题转化为：求使得 $\\forall x\\in S,y \\in T$，设 $x$ 包含的质数集合为 $P$，设 $y$ 包含的质数集合为 $P’$，有 $P∩P’=\\varnothing$，像这样的方案总数。 由于一个数的整数因数一定 $\\le$ 它本身，所以说最大的质数一定 $\\le n$，即 $p \\le n \\le 30$。其中 $p$ 表示当前情况的质数集合。 很显然，经过枚举，我们发现 $30$ 以内有 $10$ 个质数（ 所以直接暴力状压 DP，将质数的包含情况作为状态，包含为 $1$，否则为 $0$。 那么这个就是 30pts 的暴力算法了，时间复杂度 $\\Theta(2^{2p}N)$，其中 $p$ 为质数个数。 Part 2 - ? pts Algorithm我也不知道中间那两档分是用来干什么的。所以直接看正解算了吧。/kel Part 3 - 100pts Algorithm首先我们判一个数是否是质数，最暴力的是这样判的。 试除法 大概就长这样 12345function (int n)if n:0 / n:1 -&gt; back(0)for i in range(2,sqrt(n)) if !(n mod i) -&gt; back(0)back(1) 那么看到这个 $\\sqrt{n}$，这个就是解题的重点。 首先 $\\sqrt{n} \\times \\sqrt{n}=n$。 接着，分两种情况讨论质数 $p$。 $p\\ge\\sqrt{n}$ 那么设 $p \\times k=n$，则显然 $k \\le \\sqrt{n}$。 又因为因数不大于这个数本身，所以 $\\ge\\sqrt{n}$ 的数最多只有两个，即 $&gt;\\sqrt{n}$ 的数最多只有一个。 $p&lt;\\sqrt{n}$ 这个不用讲了吧。 那么又看到我们之前的暴力。 我们搞暴力，就是处理 $20$ 以内的质数。 但是现在我们发现 $&gt;\\sqrt{n}$ 的数最多只有一个，那么只要处理 $\\le \\sqrt{n}$ 的数，并且新开一个记录这个 $&gt;\\sqrt{n}$ 的数即可。 然后我们又看到 $n \\le 500$。 而 $\\sqrt{500}=22.360679775…$ 所以说这个暴力就是个铺垫嘛，处理 $22$ 反而只有八个质数。 所以我们就想到了正解，也就是，同样枚举八个质数的情况，然后再根据大质数来判断是否可选即可。 但是我们怎么能保证大质数呢？ 很显然，直接大质数从小到大结构体排个序即可。然后对于两个人取的 DP 数，直接暴力处理然后合并即可。 注意合并的时候要容斥，因为统计会同时处理两个人都不选的情况，所以在合并的时候要减掉一个原来的数值。 恭喜你，你又 A 掉了一道黑题。 时间复杂度优化为恒定 $\\Theta(2^{16}N)$ 其中有一个地方要注意一下，就是在判断一开始预处理的质数情况时，贡献一定要加到对面去而不是自己的地方，因为如果加到自己的地方，无法保证对面和自己没有重复的元素，但是因为我们已经判断过这个质数和自己的关系，所以即使这个质数情况与对面有重复，加到一起仍然与自己合法，因为一定不会有重复的地方。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;#define ri register intusing namespace std;const int N = 5e2 + 10;const int M = 1&lt;&lt;8;const int pr[8] = {2,3,5,7,11,13,17,19};int n, Mod, dp[M][M];int Mer1[M][M], Mer2[M][M];// Merge after dealing with, to DPvoid read(int &amp;ret) { ret = 0; char ch = getchar(); while (!isdigit(ch)) ch = getchar(); while (isdigit(ch)) { ret = (ret&lt;&lt;1) + (ret&lt;&lt;3) + (ch^48); ch = getchar(); } return ;}struct Number { int value; int MaxiPrime; int OtherPrime; void dealwith() { // deal with possible primes int cur = value; for (ri i=0; i&lt;8; ++i) { // choose the primes if (cur % pr[i]) continue; // can't be devided with no left OtherPrime |= (1&lt;&lt;i); while (!(cur % pr[i])) cur /= pr[i]; } if (cur &gt; 1) MaxiPrime = cur; return ; } bool operator &lt;(const Number &amp;X) const { return MaxiPrime &lt; X.MaxiPrime; }} a[N];void init() { read(n), read(Mod); for (ri i=2; i&lt;=n; ++i) a[i-1].value = i, a[i-1].dealwith(); sort(a+1, a+n), dp[0][0] = 1; return ;}void Merge(ri &amp;x, ri y) { x = (x + y) % Mod; return ;}int main() { init(); // predict: // Rolling Array, Back-to-Head Scan! for (ri i=1; i&lt;n; ++i) { if (i == 1 || a[i].MaxiPrime ^ a[i-1].MaxiPrime || !a[i].MaxiPrime) memcpy(Mer1, dp, sizeof Mer1), memcpy(Mer2, dp, sizeof Mer2); // just copy from dp to Merge for (ri j=M-1; j&gt;=0; --j) for (ri k=M-1; k&gt;=0; --k) { // enumarate each possible situation // which is of the two people if (j&amp;k) continue; // has the same elements if (!(j&amp;a[i].OtherPrime)) Merge(Mer1[j][k|a[i].OtherPrime], Mer1[j][k]); if (!(k&amp;a[i].OtherPrime)) Merge(Mer2[j|a[i].OtherPrime][k], Mer2[j][k]); # 需要注意的就是这里，不要写反了 } if (i == n-1 || a[i].MaxiPrime ^ a[i+1].MaxiPrime || !a[i].MaxiPrime) for (ri j=0; j&lt;M; ++j) for (ri k=0; k&lt;M; ++k) { if (j&amp;k) continue; // has the same elements ri to = Mer1[j][k] + Mer2[j][k] - dp[j][k]; to %= Mod, dp[j][k] = to; dp[j][k] = (dp[j][k] + Mod) % Mod; } } ri ans = 0; for (ri i=0; i&lt;M; ++i) for (ri j=0; j&lt;M; ++j) if (!(i&amp;j)) Merge(ans, dp[i][j]); cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2021/08/04/P2150-Solution/"}],"tags":[{"name":"DS","slug":"DS","link":"/tags/DS/"},{"name":"Number Theory","slug":"Number-Theory","link":"/tags/Number-Theory/"},{"name":"Others","slug":"Others","link":"/tags/Others/"},{"name":"Network Flows","slug":"Network-Flows","link":"/tags/Network-Flows/"},{"name":"Graph","slug":"Graph","link":"/tags/Graph/"},{"name":"State Compression","slug":"State-Compression","link":"/tags/State-Compression/"}],"categories":[{"name":"Notes","slug":"Notes","link":"/categories/Notes/"},{"name":"Solutions","slug":"Solutions","link":"/categories/Solutions/"},{"name":"Daily","slug":"Daily","link":"/categories/Daily/"}]}