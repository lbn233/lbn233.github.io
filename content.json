{"pages":[],"posts":[{"title":"Introduction","text":"First of all, this is my first successful hexo Blog!I may be a pigeon in the future … u1s1 hexo is better than Gridea …And maybe I will put my Luogu Blog away qaq Test for Markdown &amp; LaTeX$$\\sum\\limits_{i=1}^na_i$$","link":"/2021/08/02/Introduction/"},{"title":"Kill Network-Flows","text":"P2756 飞行员配对方案问题 只要默认前面 $m$ 个都是外国的，然后剩下的都是英国的，接着暴力建图跑 Dinic 即可。貌似只需要弄一个源点 $0$ 和汇点 $n+1$ 即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;const int N = 2e4 + 10;int n, m, cnt = 1;int head[N], dep[N];bool vis[N];struct Edge { int to, nxt, val;} e[N];void addEdge(int u, int v, int w) { e[++cnt].to = v; e[cnt].nxt = head[u]; e[cnt].val = w; head[u] = cnt; return ;}bool check() { for (int i=0; i&lt;=n+1; ++i) dep[i] = 0; dep[0] = 2; queue &lt;int&gt; sp; sp.push(0); while (!sp.empty()) { int cur = sp.front(); sp.pop(); for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (!dep[to] &amp;&amp; e[i].val) { dep[to] = dep[cur] + 1, sp.push(to); if (to==n+1) return true; } } } return false;}int dfs(int cur, int Max) { if (cur==n+1) return Max; int increase = Max; for (int i=head[cur]; i&amp;&amp;increase; i=e[i].nxt) { int to = e[i].to; if (e[i].val &amp;&amp; dep[to]==dep[cur]+1) { int res = dfs(to, min(increase, e[i].val)); e[i].val -= res, e[i^1].val += res; if (!res) dep[to] = 0; increase -= res; } } return Max-increase;}void read(int &amp;ret) { ret = 0; char ch = getchar(); int f = 1; while (!isdigit(ch) &amp;&amp; ch^'-') ch = getchar(); if (ch=='-') f = -1, ch = getchar(); while (isdigit(ch)) { ret = (ret&lt;&lt;1) + (ret&lt;&lt;3) + (ch^48); ch = getchar(); } ret *= f; return ;}int main() { read(m), read(n); while (1) { int u, v; read(u), read(v); if (u==-1 &amp;&amp; v==-1) break; addEdge(u, v, inf); addEdge(v, u, 0); } for (int i=1; i&lt;=m; ++i) addEdge(0, i, 1), addEdge(i, 0, 0); for (int i=m+1; i&lt;=n; ++i) addEdge(i, n+1, 1), addEdge(n+1, i, 0); int ans = 0; while(check()) ans += dfs(0, inf); cout &lt;&lt; ans &lt;&lt; endl; for (int i=2; i&lt;=cnt; i+=2) { if (!e[i^1].val) continue; if (!e[i].to || !e[i^1].to) continue; if (e[i].to==n+1) continue; if (e[i^1].to==n+1) continue; printf(&quot;%d %d\\n&quot;, e[i^1].to, e[i].to); } return 0;} P1251 餐巾计划问题 这道题最重要的是连边。那么很显然的拆点技巧，将一天拆成服务和收工两个点，即 i+N 和 i，后前两个点。那么源点为 0，汇点为 2*N+1。 要购买餐巾 显然从源点处购买，直接建边 add(0,i+N,inf,p)。 偷懒先不洗餐巾 显然直接延到下一天，add(i,i+1,inf,0)。 快洗 显然直接丢到 $m$ 天后，add(i,i+N+m,inf,f)。 慢洗 同理丢到 $n$ 天后，add(i,i+N+n,inf,s)。 然后每一天要跑至少为 r[i] 的流量，直接源点连收工，汇点连服务。 然后跑一遍最小费用最大流即可。 nt 的地方：DFS 要标记 cur，数组不要开小。要是写对了正解然后数组开小了那就真的是个 zz。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int MAXN = 2e3 + 10;const int inf = 2e9;int N, cnt = 1, head[MAXN*12];int p, m, f, n, s, dist[MAXN*12];bool inq[MAXN*2], vis[MAXN*2];int cost;struct Edge { int to, nxt, flow, val;} e[MAXN*12];void addEdge(int u, int v, int f, int w) { e[++cnt].to = v; e[cnt].nxt = head[u]; e[cnt].flow = f, e[cnt].val = w; head[u] = cnt; e[++cnt].to = u; e[cnt].nxt = head[v]; e[cnt].flow = 0, e[cnt].val = -w; head[v] = cnt; return ;}void read(int &amp;ret) { ret = 0; char ch = getchar(); while (!isdigit(ch)) ch = getchar(); while (isdigit(ch)) { ret = (ret&lt;&lt;1) + (ret&lt;&lt;3) + (ch^48); ch = getchar(); } return ;}bool spfa() { for (int i=0; i&lt;=2*N+1; ++i) dist[i] = inf, inq[i] = false; dist[0] = 0, inq[0] = true; queue &lt;int&gt; sp; sp.push(0); while (!sp.empty()) { int cur = sp.front(); sp.pop(); inq[cur] = false; for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (e[i].flow &amp;&amp; dist[to]&gt;dist[cur]+e[i].val) { dist[to] = dist[cur] + e[i].val; if (!inq[to]) inq[to] = true, sp.push(to); } } } return dist[2*N+1] &lt; inf;}int dfs(int cur, int Max) { if (cur == 2*N+1) { vis[cur] = true; return Max; } int increase = Max; vis[cur] = true; for (int i=head[cur]; i &amp;&amp; increase; i=e[i].nxt) { int to = e[i].to; if ((!vis[to] || to==MAXN) &amp;&amp; e[i].flow &amp;&amp; dist[to]==dist[cur]+e[i].val) { int res = dfs(to, min(increase, e[i].flow)); if (!res) continue; e[i].flow -= res, e[i^1].flow += res; cost += res * e[i].val, increase -= res; } } return Max-increase;}signed main() { cin &gt;&gt; N; for (int i=1; i&lt;=N; ++i) { int r; cin &gt;&gt; r; addEdge(0, i, r, 0); addEdge(i+N, 2*N+1, r, 0); } cin &gt;&gt; p &gt;&gt; m &gt;&gt; f &gt;&gt; n &gt;&gt; s; // begin point: i // ending point: i+N for (int i=1; i&lt;=N; ++i) { addEdge(0, i+N, inf, p); if (i&lt;N) addEdge(i, i+1, inf, 0); if (i+m&lt;=N) addEdge(i, i+N+m, inf, f); if (i+n&lt;=N) addEdge(i, i+N+n, inf, s); } while (spfa()) { for (int i=0; i&lt;=2*N+1; ++i) vis[i] = false; dfs(0, inf); } cout &lt;&lt; cost &lt;&lt; endl; return 0;} P4011 孤岛营救问题 这道题为什么要网络流啊。 难道不是直接暴力 BFS 寻找路径吗？ 直接状压一下钥匙，然后每一次到达门就看有没有钥匙就可以了。 nt 的地方：x(x), y(y) 写成了 x(x), y(x) … … 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 11;const int dx[] = {0, 1, 0, -1};const int dy[] = {1, 0, -1, 0};int n, m, p, k, s, door[N][N][N][N];int cnt[N][N], key[N][N][N];bool vis[N][N][1&lt;&lt;N];struct spread { int x, y, Key, cost; spread(int x, int y, int Key, int cost): x(x), y(y), Key(Key), cost(cost) {} spread() {}};int keyset(int x, int y) { int S = 0; for (int i=1; i&lt;=cnt[x][y]; ++i) S |= (1&lt;&lt;(key[x][y][i]-1)); return S;}bool check(int x, int y, int k, int st) { if (x&lt;1 || x&gt;n) return false; if (y&lt;1 || y&gt;m) return false; if (k&lt;0 || (k &amp;&amp; !(st&amp;(1&lt;&lt;(k-1))))) return false; return true;}int bfs() { int x = 1, y = 1; int S = keyset(x, y); queue &lt;spread&gt; que; que.push(spread(x, y, S, 0)); vis[x][y][S] = true; while (!que.empty()) { spread cur = que.front(); que.pop(); x = cur.x, y = cur.y, S = cur.Key; if (x==n &amp;&amp; y==m) return cur.cost; for (int i=0; i&lt;4; ++i) { int tox = x + dx[i], toy = y + dy[i]; int Door = door[x][y][tox][toy]; if (!check(tox, toy, Door, S)) continue; int to = S|keyset(tox, toy); if (vis[tox][toy][to]) continue; vis[tox][toy][to] = true; que.push(spread(tox, toy, to, cur.cost+1)); } } return -1;}int main() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; p &gt;&gt; k; while (k--) { int x, y, X, Y, G; cin &gt;&gt; x &gt;&gt; y &gt;&gt; X &gt;&gt; Y &gt;&gt; G; if (G) door[x][y][X][Y] = door[X][Y][x][y] = G; else door[x][y][X][Y] = door[X][Y][x][y] = -1; } cin &gt;&gt; s; while (s--) { int x, y, Q; cin &gt;&gt; x &gt;&gt; y &gt;&gt; Q; key[x][y][++cnt[x][y]] = Q; } cout &lt;&lt; bfs() &lt;&lt; endl; return 0;} P2764 最小路径覆盖问题 众所周知最小路径覆盖 $=$ 顶点数 $-$ 最大匹配数，这个是很显然的。 Proof：因为对于每一个点一开始都可以作为一条路径，所以一开始就有 $n$ 条路径。因为每一次匹配相当于把两个点合并，所以路径条数相当于减掉了 $1$，所以最大匹配数就是合并的个数，所以最后就是 $n-$最大匹配数。又因为二分图可以网络流乱搞，所以路径覆盖也可以网络流乱搞。 所以正常的 trick，拆点跑最大流。路径输出比较正常，直接在 DFS 的时候找到起始点然后记录路径即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;void read(int &amp;ret) { ret = 0; char ch = getchar(); while (!isdigit(ch)) ch = getchar(); while (isdigit(ch)) { ret = (ret&lt;&lt;1) + (ret&lt;&lt;3) + (ch^48); ch = getchar(); } return ;}const int N = 1e5 + 10;const int inf = 1e9;int n, m, s, t, cnt = 1;int dep[N], head[N]; bool inq[N];int cost, path[N]; bool vis[N];struct Edge { int to, nxt, flow;} e[N];void addEdge(int u, int v, int f) { e[++cnt].to = v; e[cnt].nxt = head[u]; e[cnt].flow = f; head[u] = cnt; e[++cnt].to = u; e[cnt].nxt = head[v]; e[cnt].flow = 0; head[v] = cnt; return ;}bool check() { for (int i=0; i&lt;=t; ++i) dep[i] = inf, inq[i] = false; dep[s] = 0; queue &lt;int&gt; sp; sp.push(s); inq[s] = true; while (!sp.empty()) { int cur = sp.front(); sp.pop(); for (int i=head[cur]; i; i=e[i].nxt) { int to = e[i].to; if (e[i].flow &amp;&amp; dep[to]==inf) { dep[to] = dep[cur] + 1, sp.push(to); } } } return dep[t] ^ inf;}int dfs(int cur, int Max) { if (cur==t) return Max; int increase = Max; for (int i=head[cur]; i &amp;&amp; increase; i=e[i].nxt) { int to = e[i].to; if (e[i].flow &amp;&amp; dep[to]==dep[cur]+1) { int res = dfs(to, min(increase, e[i].flow)); if (!res) { dep[to] = -1; continue; } e[i].flow -= res, e[i^1].flow += res; path[cur] = to; if (cur) vis[to-n] = true; increase -= res; } } return Max-increase;}int main() { cin &gt;&gt; n &gt;&gt; m; t = 2*n+1; for (int i=1; i&lt;=m; ++i) { int u, v; cin &gt;&gt; u &gt;&gt; v; addEdge(u, n+v, 1); } for (int i=1; i&lt;=n; ++i) addEdge(s, i, 1); for (int i=1; i&lt;=n; ++i) addEdge(i+n, t, 1); int ans = 0; while (check()) ans += dfs(s, inf); for (int i=1; i&lt;=n; ++i) { if (vis[i]) continue; int cur = i; cout &lt;&lt; i; while(path[cur] &amp;&amp; path[cur]^t) cout &lt;&lt; ' ' &lt;&lt; path[cur]-n, cur = path[cur]-n; cout &lt;&lt; endl; } cout &lt;&lt; n-ans &lt;&lt; endl; return 0;} P4016 负载平衡问题 听名字还挺高大上的。 其实就是个卡牌游戏啊，只不过每一次只可以交换环上相邻两个。那么直接断环成链，拿原数减掉最后的固定答案然后前缀和加到 ans。 顺带卡了下常，12ms 最优解 Rank1。 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;int n, sum, ans, a[110], Sum[110];int abs(int x) { return x&gt;0? x:-x; }void qsort(int l, int r) { int mid = Sum[(l+r)&gt;&gt;1]; int i=l, j=r; do { while (Sum[i]&lt;mid) ++i; while (Sum[j]&gt;mid) --j; if(i&lt;=j) { int u=Sum[i]; Sum[i]=Sum[j]; Sum[j]=u; i++, j--; } } while (i&lt;=j); if (l&lt;j) qsort(l, j); if (i&lt;r) qsort(i, r); return ;}int main() { scanf(&quot;%d&quot;, &amp;n); for (int i=1; i&lt;=n; ++i) scanf(&quot;%d&quot;, &amp;a[i]), sum += a[i]; sum /= n; for (int i=1; i&lt;=n; ++i) Sum[i] = Sum[i-1]+a[i]-sum, a[i] = Sum[i]; qsort(1, n); int mid = n/2+1; for (int i=1; i&lt;=n; ++i) ans += abs(Sum[mid]-Sum[i]); printf(&quot;%d\\n&quot;, ans); return 0;}","link":"/2021/08/02/Kill-Network-Flows/"}],"tags":[{"name":"Others","slug":"Others","link":"/tags/Others/"},{"name":"Network Flows","slug":"Network-Flows","link":"/tags/Network-Flows/"}],"categories":[]}